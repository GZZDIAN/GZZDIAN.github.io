<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="false" > 
<link href="/fontawesome/css/fontawesome.css" rel="stylesheet">
<link href="/fontawesome/css/brands.css" rel="stylesheet">
<link href="/fontawesome/css/solid.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  <title>Mysql高级 | gzzear&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Mysql高级一、逻辑架构1. 逻辑架构剖析1.1 服务器处理客户端请求那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢?这里以查询请求为例展示:   下面具体展开看一下:  1.2 第一层: 连接层系统(客户端)访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。 经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql高级">
<meta property="og:url" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/index.html">
<meta property="og:site_name" content="gzzear&#39;s blog">
<meta property="og:description" content="Mysql高级一、逻辑架构1. 逻辑架构剖析1.1 服务器处理客户端请求那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢?这里以查询请求为例展示:   下面具体展开看一下:  1.2 第一层: 连接层系统(客户端)访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。 经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702205138894.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702205358121.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702214245169.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702214602277.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702215841007.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702220432990.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702221820015.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702222020863.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702222604812.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702224021722.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702224232744.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702224323248.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702224348834.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702224545465.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702224635740.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702233218281.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702233322881.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702234605609.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702234814768.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702235235390.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702235554193.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702235841547.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230703000712685.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230703001029859.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230703002026722.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230703003213262.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230703003407727.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230703004201465.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230703102832651.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230703091218885.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220325180029352.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220325181405473.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220325181420603.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220325181712981.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220325195048342.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326113218648.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326120805996-8347999.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326121611806-8347999.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326122616487.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326122717663.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326122751920.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326122857145.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326123056983.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326123147690.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326125611904.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326125627303.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326122751920.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326130111650.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326130433291.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326141653065.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326142034981.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220325201510359.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326170537304.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326171219278.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326172022150.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326172126970.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326172256011.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326172802426.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326173156258.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326173338273.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326173520015.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326173622086.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326173721122.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326182016458.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326182155207.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326183048710.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326183135116.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230704091236416.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230704091632501.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230704091859240.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230704092747844.png">
<meta property="og:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230704100613460.png">
<meta property="article:published_time" content="2023-07-02T12:45:55.563Z">
<meta property="article:modified_time" content="2023-07-15T02:56:38.705Z">
<meta property="article:author" content="gaozhe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702205138894.png">
  
    <link rel="alternate" href="/atom.xml" title="gzzear's blog" type="application/atom+xml">
  
  
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-192.png" sizes="192x192">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-192.png" sizes="192x192">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  
   
  <div id="main-grid" class="shadow   ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>gzzear's blog </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="material-symbols-rounded light-mode-icon">wb_sunny</span>
      <span class="material-symbols-rounded dark-mode-icon">dark_mode</span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/atom.xml" title="RSS Feed">
        <span class="material-symbols-rounded rss">rss_feed</span>
      </a>
    
    <a id="nav-search-btn" class="nav-icon" title="Search" style="display: none;">
      <span class="material-symbols-rounded">search</span>
    </a>
    <div id="nav-menu-btn" class="nav-icon">
      <span class="material-symbols-rounded">menu</span>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">Home</a>
    
      <a class="nav-dropdown-link" href="/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/about">About</a>
    
    
      <a class="nav-dropdown-link" href="/atom.xml" title="RSS Feed">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">高喆 </div>
      <div class="dot"></div>
      <div class="subtitle">私人博客记录学习文档 </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://twitter.com" title="Twitter"><i class="fa-brands fa-twitter"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://store.steampowered.com" title="Steam"><i class="fa-brands fa-steam"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com" title="GitHub"><i class="fa-brands fa-github"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      



    
      

    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Archives</h3>
      
      
        <a class="archive-link" href="/archives/2023/07 ">
          July 2023 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/06 ">
          June 2022 
          <div class="archive-count">1 </div>
        </a>
      
        <a class="archive-link" href="/archives/2022/01 ">
          January 2022 
          <div class="archive-count">1 </div>
        </a>
      
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Recent Posts</h3>
      <ul>
        
          <li>
            <a href="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/">Mysql高级</a>
          </li>
        
          <li>
            <a href="/2022/06/16/MySQL45%E8%AE%B2/">MySql45讲</a>
          </li>
        
          <li>
            <a href="/2022/01/26/SpringSecurity/">SpringSecurity</a>
          </li>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       

<article id="post-Mysql高级" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        Mysql高级
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2023-07-02T12:45:55.563Z" itemprop="datePublished">2023-07-02</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
    Uncategorized 
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            31k words 
          </div>
        </div>
        
      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <h1 id="Mysql高级"><a href="#Mysql高级" class="headerlink" title="Mysql高级"></a>Mysql高级</h1><h2 id="一、逻辑架构"><a href="#一、逻辑架构" class="headerlink" title="一、逻辑架构"></a>一、逻辑架构</h2><h4 id="1-逻辑架构剖析"><a href="#1-逻辑架构剖析" class="headerlink" title="1. 逻辑架构剖析"></a>1. 逻辑架构剖析</h4><h5 id="1-1-服务器处理客户端请求"><a href="#1-1-服务器处理客户端请求" class="headerlink" title="1.1 服务器处理客户端请求"></a>1.1 服务器处理客户端请求</h5><p>那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢?这里以查询请求为例展示:</p>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702205138894.png" alt="image-20230702205138894" style="zoom:50%;">

<p>下面具体展开看一下:</p>
<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702205358121.png" alt="image-20230702205358121"></p>
<h5 id="1-2-第一层-连接层"><a href="#1-2-第一层-连接层" class="headerlink" title="1.2 第一层: 连接层"></a>1.2 第一层: 连接层</h5><p>系统(客户端)访问 MySQL 服务器前，做的第一件事就是建立 TCP 连接。 经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。</p>
<ul>
<li>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</li>
<li>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依 赖于此时读到的权限</li>
</ul>
<p>TCP 连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后 面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。</p>
<h5 id="1-3-第二层-服务层"><a href="#1-3-第二层-服务层" class="headerlink" title="1.3 第二层:服务层"></a>1.3 第二层:服务层</h5><ul>
<li><p><span style="color:red;">SQL Interface: SQL接口</span></p>
<ul>
<li>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT … FROM就是调用SQL Interface</li>
<li>MySQL支持DML(数据操作语言)、DDL(数据定义语言)、存储过程、视图、触发器、自定 义函数等多种SQL语言接口</li>
</ul>
</li>
<li><p><span style="color:red;">Parser: 解析器</span></p>
<ul>
<li>在解析器中对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构 传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错 误，那么就说明这个SQL语句是不合理的。</li>
</ul>
</li>
<li><p><span style="color:red;">Optimizer: 查询优化器</span></p>
<ul>
<li><p>SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个 <strong>执行计划</strong> 。</p>
</li>
<li><p>这个执行计划表明应该 使用<strong>哪些索引</strong> 进行查询(全表检索还是使用索引检索)，表之间的连 接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将 查询结果返回给用户。</p>
</li>
<li><p>它使用“ <strong>选取-投影-连接</strong> ”策略进行查询。例如:</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,name FROM student WHERE gender = &#x27;女&#x27;;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>这个SELECT查询先根据WHERE语句进行 <strong>选取</strong> ，而不是将表全部查询出来以后再进行gender过 滤。 这个SELECT查询先根据id和name进行属性 <strong>投影</strong> ，而不是将属性全部取出以后再进行过 滤，将这两个查询条件 <strong>连接</strong> 起来生成最终查询结果</p>
</li>
<li><p><span style="color:red;">Caches &amp; Buffers: 查询缓存组件</span></p>
<ul>
<li>MySQL内部维持着一些Cache和Buffer，比如Query Cache用来缓存一条SELECT语句的执行结 果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过 程了，直接将结果反馈给客户端。</li>
<li>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等 。</li>
<li>这个查询缓存可以在 不同客户端之间共享 。</li>
<li>从MySQL 5.7.20开始，不推荐使用查询缓存，<strong>并在 MySQL 8.0中删除</strong> 。</li>
</ul>
</li>
</ul>
<h5 id="1-4-第三层-引擎层"><a href="#1-4-第三层-引擎层" class="headerlink" title="1.4 第三层:引擎层"></a>1.4 第三层:引擎层</h5><p>插件式存储引擎层( Storage Engines)，<strong>真正的负责了MySQL中数据的存储和提取</strong>，<strong>对物理服务器级别 维护的底层数据执行操作</strong> ，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样 我们可以根据自己的实际需要进行选取。</p>
<h5 id="1-5-第四层-存储层"><a href="#1-5-第四层-存储层" class="headerlink" title="1.5 第四层:存储层"></a>1.5 第四层:存储层</h5><p>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在 文件系统 上，以 文件 的方式存 在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设 备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用 DAS、NAS、SAN等各种存储系统。</p>
<blockquote>
<p>小结</p>
</blockquote>
<p>MySQL架构图本节开篇所示。下面为了熟悉SQL执行流程方便，我们可以简化如下:</p>
 <img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702214245169.png" alt="image-20230702214245169" style="zoom:50%;">





<p>简化为三层结构:</p>
<ol>
<li>连接层:客户端和服务器端建立连接，客户端发送 SQL 至服务器端;</li>
<li>SQL 层(服务层):对 SQL 语句进行查询处理;与数据库文件的存储方式无关;</li>
<li>存储引擎层:与数据库文件打交道，负责数据的存储和读取。</li>
</ol>
<h2 id="二、SQL执行流程"><a href="#二、SQL执行流程" class="headerlink" title="二、SQL执行流程"></a>二、SQL执行流程</h2><h3 id="2-1-MySQL-中的-SQL执行流程"><a href="#2-1-MySQL-中的-SQL执行流程" class="headerlink" title="2.1 MySQL 中的 SQL执行流程"></a>2.1 MySQL 中的 SQL执行流程</h3><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702214602277.png" alt="image-20230702214602277" style="zoom:50%;">



<p><strong><span style="color:red;">MySQL的查询流程:</span></strong></p>
<ol>
<li><strong><span style="color:red;">查询缓存:</span></strong> Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端;如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，所以在 MySQL8.0 之后就抛弃 了这个功能。</li>
</ol>
<p>​	<span style="color:red;"><strong>大多数情况查询缓存就是个鸡肋，为什么呢?</strong></span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_id,last_name FROM employees WHERE employee_id = 101;</span><br></pre></td></tr></table></figure>

<p>查询缓存是提前把查询结果缓存起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。两个查询请求在任何字符上的不同(例如:空格、注释、 大小写)，都会导致缓存不会命中。因此 MySQL 的  <strong>查询缓存命中率不高</strong>。</p>
<p>同时，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、 information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。以某些系统函数 举例，可能同样的函数的两次调用会产生不一样的结果，比如函数NOW，每次调用都会产生最新的当前 时间，如果在一个查询请求中调用了这个函数，那即使查询请求的文本信息都一样，那不同时间的两次 查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询 的结果就是错误的!</p>
<p>此外，既然是缓存，那就有它缓存失效的情况。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了INSERT、UPDATE、DELETE、TRUNCATE TABLE、ALTER TABLE、DROP TABLE语句.那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除!对于更新压力过大的数据库来说,查询缓存的命中率会非常低。</p>
<ol start="2">
<li><span style="color:red;"><strong>解析器:</strong></span>在解析器中对 SQL 语句进行语法分析、语义分析</li>
</ol>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702215841007.png" alt="image-20230702215841007" style="zoom:50%;">

<p>分析器先做“ <strong>词法分析</strong> ”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面 的字符串分别是什么，代表什么。 MySQL 从你输入的”select”这个关键字识别出来，这是一个查询语 句。它也要把字符串“T”识别成“表名 T”，把字符串“ID”识别成“列 ID”。</p>
<p>接着，要做“ <strong>语法分析</strong> ”。根据词法分析的结果，语法分析器(比如:Bison)会根据语法规则，判断你输 入的这个SQL语句是否<strong>满足 MySQL 语法</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select department_id,job_id,avg(salary) from employees group by department_id;</span><br></pre></td></tr></table></figure>

<p>如果SQL语句正确，则会生成一个这样的语法树:</p>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702220432990.png" alt="image-20230702220432990" style="zoom:50%;">



<ol start="3">
<li><span style="color:red;"><strong>优化器:</strong></span>在优化器中会确定 SQL 语句的执行路径，比如是根据 全表检索 ，还是根据 索引检索 等。 举例:如下语句是执行两个表的 join:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from test1 join test2 using(ID)</span><br><span class="line">where test1.name=&#x27;zhangwei&#x27; and test2.name=&#x27;./Mysql高级课程&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方案1:可以先从表 test1 里面取出 name=&#x27;zhangwei&#x27;的记录的 ID 值，再根据 ID 值关联到表 test2，再判 断 test2 里面 name的值是否等于 &#x27;./Mysql高级课程&#x27;。</span><br><span class="line"></span><br><span class="line">方案2:可以先从表 test2 里面取出 name=&#x27;./Mysql高级课程&#x27; 的记录的 ID 值，再根据 ID 值关联到 test1， 再判断 test1 里面 name的值是否等于 zhangwei。</span><br><span class="line"></span><br><span class="line">这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化</span><br><span class="line">器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</span><br><span class="line">如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等。后面讲到索引我们再谈。</span><br></pre></td></tr></table></figure>

<p>在查询优化器中，可以分为 <strong>逻辑查询</strong> 优化阶段和 <strong>物理查询</strong> 优化阶段。</p>
<ol start="4">
<li><span style="color:red;"><strong>执行器:</strong></span></li>
</ol>
<p>截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了 <strong>执行器阶段</strong> 。</p>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702221820015.png" alt="image-20230702221820015" style="zoom:50%;">

<p>在执行之前需要判断该用户是否 <strong>具备权限</strong> 。如果没有，就会返回权限错误。如果具备权限，就执行 SQL 查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test where id=1;</span><br></pre></td></tr></table></figure>

<p>比如:表 test 中，ID 字段没有索引，那么执行器的执行流程是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是1，如果不是则跳过，如果是则将这行存在结果集中; 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</span><br><span class="line"></span><br><span class="line">执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</span><br></pre></td></tr></table></figure>

<p>至此，这个语句就执行完成了。对于有索引的表，执行的逻辑也差不多。</p>
<p>SQL 语句在 MySQL 中的流程是: SQL语句→查询缓存→解析器→优化器→执行器 。</p>
<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702222020863.png" alt="image-20230702222020863"></p>
<h3 id="2-2-SQL语法顺序"><a href="#2-2-SQL语法顺序" class="headerlink" title="2.2 SQL语法顺序"></a>2.2 SQL语法顺序</h3><p>随着Mysql版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同</p>
<p>而动态调整执行顺序。 需求:查询每个部门年龄高于20岁的人数且高于20岁人数不能少于2人，显示人数最多的第一名部门信息 下面是经常出现的查询顺序:</p>
<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702222604812.png" alt="image-20230702222604812"></p>
<h2 id="三、数据库缓冲池-buffer-pool"><a href="#三、数据库缓冲池-buffer-pool" class="headerlink" title="三、数据库缓冲池(buffer pool)"></a>三、数据库缓冲池(buffer pool)</h2><p><strong>Innodb</strong>存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页 面(包括读页面、写页面、创建新页面等操作)。而磁盘 I&#x2F;O 需要消耗的时间很多，而在内存中进行操 作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会<strong>申请占用内存作为数据的缓冲池</strong>，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的<strong>Buffer Pool</strong>之后才可以访 问。</p>
<p>这样做的好处是可以让磁盘活动最小化，<strong>从而减少磁盘IO次数</strong> 。要知道，这种策略对提 升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p>
<h3 id="3-1-缓冲池-vs-查询缓存"><a href="#3-1-缓冲池-vs-查询缓存" class="headerlink" title="3.1 缓冲池 vs 查询缓存"></a>3.1 缓冲池 vs 查询缓存</h3><p><span style="color:red;"><strong>缓冲池和查询缓存是一个东西吗?不是。</strong></span></p>
<blockquote>
<p>缓冲池(Buffer Pool)</p>
</blockquote>
<p>首先我们需要了解在 InnoDB 存储引擎中，缓冲池都包括了哪些。</p>
<p>在 InnoDB 存储引擎中有一部分数据会放到内存中，缓冲池则占了这部分内存的大部分，它用来存储各种 数据的缓存，如下图所示:</p>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702224021722.png" alt="image-20230702224021722" style="zoom:50%;">

<p>从图中，你能看到 InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应 Hash 和数据字典 信息等。</p>
<blockquote>
<p>查询缓存</p>
</blockquote>
<p>那么什么是查询缓存呢?</p>
<p>查询缓存是提前把 <strong>查询结果缓存</strong> 起来，这样下次不需要执行就可以直接拿到结果。需要说明的是，在 MySQL 中的查询缓存，不是缓存查询计划，而是查询对应的结果。因为命中条件苛刻，而且只要数据表 发生变化，查询缓存就会失效，因此命中率低。</p>
<h3 id="3-2-缓冲池如何读取数据"><a href="#3-2-缓冲池如何读取数据" class="headerlink" title="3.2 缓冲池如何读取数据"></a>3.2 缓冲池如何读取数据</h3><p>缓冲池管理器会尽量将经常使用的数据保存起来，在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。</p>
<p>缓存在数据库中的结构和作用如下图所示:</p>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702224232744.png" alt="image-20230702224232744" style="zoom:50%;">

<p><strong>如果我们执行 SQL 语句的时候更新了缓存池中的数据，那么这些数据会马上同步到磁盘上吗?</strong></p>
<h3 id="3-3-查看-设置缓冲池的大小"><a href="#3-3-查看-设置缓冲池的大小" class="headerlink" title="3.3 查看&#x2F;设置缓冲池的大小"></a>3.3 查看&#x2F;设置缓冲池的大小</h3><p>如果你使用的是InnoDB存储引擎，可以通过查看 innodb_buffer_pool_size 变量来查看缓冲池的大 小。命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_buffer_pool_size&#x27;;</span><br></pre></td></tr></table></figure>

<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702224323248.png" alt="image-20230702224323248" style="zoom:50%;">

<p>你能看到此时 InnoDB 的缓冲池大小只有 134217728&#x2F;1024&#x2F;1024&#x3D;128MB。我们可以修改缓冲池大小，比如 改为256MB，方法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global innodb_buffer_pool_size = 268435456;</span><br></pre></td></tr></table></figure>

<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702224348834.png" alt="image-20230702224348834" style="zoom:50%;">

<p>或者:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size = 268435456</span><br></pre></td></tr></table></figure>

<p>然后再来看下修改后的缓冲池大小，此时已成功修改成了 256 MB:</p>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702224545465.png" alt="image-20230702224545465" style="zoom:50%;">





<h3 id="3-4-多个Buffer-Pool实例"><a href="#3-4-多个Buffer-Pool实例" class="headerlink" title="3.4 多个Buffer Pool实例"></a>3.4 多个Buffer Pool实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances = 2</span><br></pre></td></tr></table></figure>

<p>这样就表明我们要创建2个 Buffer Pool 实例。 </p>
<p>我们看下如何查看缓冲池的个数，使用命令:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;innodb_buffer_pool_instances&#x27;;</span><br></pre></td></tr></table></figure>

<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702224635740.png" alt="image-20230702224635740" style="zoom:50%;">

<p>那每个 Buffer Pool 实例实际占多少内存空间呢?其实使用这个公式算出来的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">innodb_buffer_pool_size/innodb_buffer_pool_instances</span><br></pre></td></tr></table></figure>

<p>也就是总共的大小除以实例的个数，结果就是每个 Buffer Pool 实例占用的大小。</p>
<h2 id="四、索引"><a href="#四、索引" class="headerlink" title="四、索引"></a>四、索引</h2><blockquote>
<p>为什么使用索引</p>
</blockquote>
<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702233218281.png" alt="image-20230702233218281"></p>
<p>假如给数据使用 二叉树 这样的数据结构进行存储，如下图所示</p>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702233322881.png" alt="image-20230702233322881" style="zoom:50%;">



<h3 id="4-1-索引及其优缺点"><a href="#4-1-索引及其优缺点" class="headerlink" title="4.1 索引及其优缺点"></a>4.1 索引及其优缺点</h3><blockquote>
<p>索引概述</p>
</blockquote>
<p>MySQL官方对索引的定义为: <strong>索引(Index)是帮助MySQL高效获取数据的数据结构 。</strong></p>
<p><strong>索引的本质: 索引是数据结构。</strong>你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。</p>
<p>这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上<strong>实现高级查找算法</strong></p>
<blockquote>
<p>优点</p>
</blockquote>
<p>(1)类似大学图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本, 这也是创建索引的原因</p>
<p>(2)通过创建唯一索引，可以保证数据库表中每一行数据的唯一性</p>
<p>(3)参考完整性方面，可以加速表与表直接的连接速度 。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度</p>
<p>(4)在使用分组和排序子句进行数据查询时，可以显著提高查询与分组的速度, 降低了cpu的消耗</p>
<blockquote>
<p>缺点</p>
</blockquote>
<p>增加索引也有许多不利的方面，主要表现在如下几个方面:</p>
<p>(1)创建索引和维护索引要消耗时间 ，并 且随着数据量的增加，所耗费的时间也会增加。</p>
<p>(2)索引需要占磁盘空间，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间，存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</p>
<p>(3)虽然索引大大提高了查询速度，同时却会降低表的更新速度 。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</p>
<p>因此，选择使用索引时，需要综合考虑索引的优点和缺点。</p>
<h3 id="4-2-索引的数据结构推演"><a href="#4-2-索引的数据结构推演" class="headerlink" title="4.2 索引的数据结构推演"></a>4.2 索引的数据结构推演</h3><p>先来看一个精确匹配的例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT [列名列表] FROM 表名 WHERE 列名 = xxx;</span><br></pre></td></tr></table></figure>

<p>在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录 所在的页，所以只能 沿着 一直往下找，在每一个页中根据我们上面的查找方式去查 找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 的。如果一个表有一亿条记录 呢?此时索引应运而生。</p>
<blockquote>
<p>设计索引</p>
</blockquote>
<p>建一个表:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE index_demo(</span><br><span class="line">-&gt; c1 INT,</span><br><span class="line">-&gt; c2 INT,</span><br><span class="line">    -&gt;     c3 CHAR(1),</span><br><span class="line">    -&gt;     PRIMARY KEY(c1)</span><br><span class="line">    -&gt; ) ROW_FORMAT = Compact;</span><br></pre></td></tr></table></figure>

<p>这个新建的index_demo 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键， 这个表使用Compact行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图:</p>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702234605609.png" alt="image-20230702234605609" style="zoom:50%;">



<p>我们只在示意图里展示记录的这几个部分:</p>
<ul>
<li><p>record_type :记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记录、 3 表示最大记录、 1 暂时还没用过，下面讲。</p>
</li>
<li><p>next_record :记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用箭头来表明下一条记录是谁。</p>
</li>
<li><p>各个列的值: 这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。</p>
</li>
<li><p>其他信息: 除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。</p>
</li>
</ul>
<p>将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样:</p>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702234814768.png" alt="image-20230702234814768" style="zoom:50%;">



<p>把一些记录放到页里的示意图就是:</p>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702235235390.png" alt="image-20230702235235390" style="zoom:50%;">





<blockquote>
<p>一个简单的索引设计方案</p>
</blockquote>
<p>我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢?因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们想快速定位到需要查找的记录在哪些数据页中该咋办?我们可以为快速定位记录所在的数据页而想快速的定位到需要查找的记录在哪些数据页建立一个目录，建这个目录必须完成下边这些事:</p>
<ul>
<li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。</li>
<li>给所有的页建立一个目录项。</li>
</ul>
<p>所以我们为上边几个页做好的目录就像这样子:</p>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702235554193.png" alt="image-20230702235554193" style="zoom:50%;">

<p>以 页28 为例，它对应目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主键值 5 。我们只需要把几个目录项在物理存储器上连续存储(比如:数组)，就可以实现根据主键 值快速查找某条记录的功能了。比如:查找主键值为 20 的记录，具体查找过程分两步:</p>
<ol>
<li>先从目录项中根据 二分法 快速确定出主键值为 20 的记录在 目录项3 中(因为 12 &lt; 20 &lt; 209 )，它对应的页是 页9 。</li>
<li>再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。</li>
</ol>
<p>至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 索引 。</p>
<blockquote>
<p>迭代1次:目录项纪录的页</p>
</blockquote>
<p>我们把前边使用到的目录项放到数据页中的样子就是这样:</p>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230702235841547.png" alt="image-20230702235841547" style="zoom:50%;">



<p>从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调目录项纪录和普通的用户记录的不同点:</p>
<ul>
<li>目录项记录的record_type 值是1，而普通用户记录的record_type值是0。</li>
<li>目录项记录只有两个列，而普通的用户记录的列是用户自己定义的，可能包含很多列 ，另外还有InnoDB自己添加的隐藏列。</li>
<li>了解:记录头信息里还有一个叫min_rec_mask的属性，只有在存储目录项纪录的页中的主键值最小的目录项记录的min_rec_mask值为 1 ，其他别的记录的min_rec_mask值都是 0 。</li>
</ul>
<p>**相同点:**两者用的是一样的数据页，都会为主键值生成 Page Directory (页目录)，从而在按照主键 值进行查找时可以使用 二分法 来加快查询速度。</p>
<p>现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步:</p>
<ol>
<li><p>先到存储目录项记录的页，也就是页30中通过 二分法 快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9。</p>
</li>
<li><p>再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录。</p>
</li>
</ol>
<blockquote>
<p>迭代2次:多个目录项纪录的页</p>
</blockquote>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230703000712685.png" alt="image-20230703000712685" style="zoom:50%;">

<p>从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页:</p>
<ul>
<li>为存储该用户记录而新生成了 页31 。</li>
<li>因为原先存储目录项记录的 页30的容量已满 (我们前边假设只能存储4条目录项记录)，所以不得 不需要一个新的 页32 来存放 页31 对应的目录项。</li>
</ul>
<p>现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 20 的记录为例:</p>
<ol>
<li>确定 目录项记录页</li>
</ol>
<p>​		我们现在的存储目录项记录的页有两个，即 页30 和 页32 ，又因为页30表示的目录项的主键值的 范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目 录项记录在 页30 中。</p>
<ol start="2">
<li><p>通过目录项记录页 确定用户记录真实所在的页 。</p>
<p>在一个存储 目录项记录 的页中通过主键值定位一条目录项记录的方式说过了。</p>
</li>
<li><p>在真实存储用户记录的页中定位到具体的记录。</p>
</li>
</ol>
<blockquote>
<p>迭代3次:目录项记录页的目录页</p>
</blockquote>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230703001029859.png" alt="image-20230703001029859" style="zoom:50%;">

<p>如图，我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用 户记录的主键值在 [1, 320) 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的 话，就到页32中查找更详细的目录项记录。</p>
<p>我们可以用下边这个图来描述它:</p>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230703002026722.png" alt="image-20230703002026722" style="zoom:50%;">

<p>这个数据结构，它的名称是 B+树 。</p>
<blockquote>
<p>B+Tree</p>
</blockquote>
<p>一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设:存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 1000条目录项记录 ，那么:</p>
<ul>
<li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。</li>
<li>如果B+树有2层，最多能存放 1000x100&#x3D;10,0000 条记录。</li>
<li>如果B+树有3层，最多能存放  1000x1000x100&#x3D;10000,0000 条记录。</li>
<li>如果B+树有4层，最多能存放 1000x1000x1000x100&#x3D;1000,0000,0000条记录。相当多的记录!!!</li>
</ul>
<p>你的表里能存放 100000000000 条记录吗?所以一般情况下，我们 用到的B+树都不会超过4层 ，那我们 通过主键值去查找某条记录最多只需要做4个页面内的查找(查找3个目录项页和一个用户记录页)，又 因为在每个页面内有所谓的 Page Directory (页目录)，所以在页面内也可以通过 二分法 实现快速 定位记录。</p>
<h3 id="4-3-常见索引概念"><a href="#4-3-常见索引概念" class="headerlink" title="4.3 常见索引概念"></a>4.3 常见索引概念</h3><p>索引按照物理实现方式，索引可以分为 2 种:聚簇(聚集)和非聚簇(非聚集)索引。我们也把非聚集索引称为二级索引或者辅助索引。</p>
<blockquote>
<p>聚簇索引</p>
</blockquote>
<p><strong>特点:</strong></p>
<ol>
<li>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义:</li>
</ol>
<ul>
<li>页内 的记录是按照主键的大小顺序排成一个 单向链表 。</li>
<li>各个存放用户记录页也是根据页中用户记录的主键大小顺序排成一个双向链表 。</li>
<li>存放目录页记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排出一个双向链表</li>
</ul>
<ol start="2">
<li>B+树的 叶子节点 存储的是完整的用户记录。</li>
</ol>
<p>所谓完整的用户记录，就是指这个记录中存储了所有列的值(包括隐藏列)。</p>
<p><strong>优点:</strong></p>
<ul>
<li><strong>数据访问更快</strong> ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非 聚簇索引更快</li>
<li>聚簇索引对于主键的 排序查找 和 范围查找 速度非常快</li>
<li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 节省了大量的io操作 。</li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个 <strong>自增的ID列为主键</strong></li>
<li>更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为 不可更新</li>
<li>二级索引访问需要两次索引查找 ，第一次找到主键值，第二次根据主键值找到行数据</li>
</ul>
<blockquote>
<p> 二级索引(辅助索引、非聚簇索引)</p>
</blockquote>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230703003213262.png" alt="image-20230703003213262" style="zoom:50%;">

<p>**概念:**回表 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根 据c2列的值查找到完整的用户记录的话，仍然需要到 <strong>聚簇索引</strong> 中再查一遍，这个过程称为 回表 。也就 是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树!</p>
<p>**问题:**为什么我们还需要一次 <strong>回表</strong> 操作呢?直接把完整的用户记录放到叶子节点不OK吗?</p>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230703003407727.png" alt="image-20230703003407727" style="zoom:50%;">





<blockquote>
<p> 联合索引</p>
</blockquote>
<p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照 c2和c3列 的大小进行排序，这个包含两层含义:</p>
<ul>
<li>先把各个记录和页按照c2列进行排序</li>
<li>在记录的c2列相同的情况下，采用c3列进行排序</li>
</ul>
<p>注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下:</p>
<ul>
<li>建立 <strong>联合索引</strong> 只会建立如上图一样的1棵B+树。</li>
<li>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</li>
</ul>
<blockquote>
<p>MyISAM 与 InnoDB对比</p>
</blockquote>
<p><span style="color:red;"><strong>MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区别:</strong></span></p>
<ol>
<li>在InnoDB存储引擎中，我们只需要根据主键值对 聚簇索引 进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次 回表 操作，意味着MyISAM中建立的索引相当于全部都是 二级索引 。</li>
<li>InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 分离的 ，索引文件仅保存数 据记录的地址。</li>
<li>InnoDB的非聚簇索引data域存储相应记录 主键的值 ，而MyISAM索引记录的是 地址 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域。</li>
<li>MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通 过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。</li>
<li>InnoDB要求表 必须有主键 ( MyISAM可以没有 )。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐 含字段作为主键，这个字段长度为6个字节，类型为长整型。</li>
</ol>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230703004201465.png" alt="image-20230703004201465" style="zoom:50%;">





<h3 id="4-4-索引的代价"><a href="#4-4-索引的代价" class="headerlink" title="4.4 索引的代价"></a>4.4 索引的代价</h3><p>索引是个好东西，可不能乱建，它在空间和时间上都会有消耗:</p>
<ul>
<li>空间上的代价</li>
</ul>
<p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。</p>
<ul>
<li>时间上的代价</li>
</ul>
<p>每次对表中的数据进行 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每 层节点都是按照索引列的值 而组成了 双向链表 。不论是叶子节点中的记录，还 是内节点中的记录(也就是不论是用户记录还是目录项记录)都是按照索引列的值从小到大的顺序 而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需 要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。</p>
<h3 id="4-5-索引的声明与使用"><a href="#4-5-索引的声明与使用" class="headerlink" title="4.5 索引的声明与使用"></a>4.5 索引的声明与使用</h3><blockquote>
<p>索引的分类</p>
</blockquote>
<p>MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。</p>
<ul>
<li>从功能上说，索引主要有 4 种，分别是<ul>
<li>普通索引: 不加任何限制条件，只为提高查询效率的索引。</li>
<li>唯一索引: 限制该索引的值必须是唯一的，但允许有空值，一张表可以有多个唯一索引</li>
<li>主键索引: 一种特殊的唯一索引，增加了不为空的约束，一张表最多只有一个主键索引。</li>
<li>全文索引: 利用<code>分词技术</code>等多种算法分析关键词的频率和重要性筛选，适合大型数据集。</li>
</ul>
</li>
<li>根据物理实现方式来说，索引可以分为 2 种:<ul>
<li>聚簇索引: 针对主键构建的索引，是一种数据存储方式，表的数据行都存放在索引树的叶子页中。</li>
<li>非聚簇索引: 针对非主键构建的索引，它不保存完整记录，且按照索引列排序</li>
</ul>
</li>
<li>按照作用字段进行划分，分成:<ul>
<li>单列索引: 单个列上创建的索引，可以是普通索引、唯一索引、主键索引等</li>
<li>联合索引: 多个字段组合创建的索引，使用联合索引时遵循 最左前缀原则。</li>
</ul>
</li>
</ul>
<p>小结:不同的存储引擎支持的索引类型也不一样 InnoDB :支持 B-tree、Full-text 等索引，不支持 Hash 索引; MyISAM : 支持 B-tree、Full-text 等索引，不支持 Hash 索引; Memory :支持 B-tree、Hash 等 索引，不支持 Full-text 索引; NDB :支持 Hash 索引，不支持 B-tree、Full-text 等索引; Archive :不支 持 B-tree、Hash、Full-text 等索引;</p>
<blockquote>
<p>创建索引</p>
</blockquote>
<p>创建表的时候创建索引</p>
<p>举例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE dept(</span><br><span class="line">dept_id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">dept_name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE emp(</span><br><span class="line">emp_id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">emp_name VARCHAR(20) UNIQUE,</span><br><span class="line">dept_id INT,</span><br><span class="line">CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>但是，如果显式创建表时创建索引的话，基本语法格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name [col_name data_type]</span><br><span class="line">[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [index_name] (col_name [length]) [ASC |</span><br><span class="line">DESC]</span><br></pre></td></tr></table></figure>



<ul>
<li><code>UNIQUE</code>、 <code>FULLTEXT</code> 和 <code>SPATIAL</code> 为可选参数，分别表示唯一索引、全文索引和空间索引; 与 KEY 为同义词，两者的作用相同，用来指定创建索引;</li>
<li><code>INDEX</code> 与<code>KEY</code>为同义词，两者的作用相同，用来指定创建索引;</li>
<li><code>index_name</code>指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名;</li>
<li><code>col_name</code>为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择;</li>
<li><code>length</code>为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度;</li>
<li><code>ASC</code>和<code>DESC</code>指定升序或者降序的索引值存储。</li>
</ul>
<ol>
<li>创建普通索引</li>
</ol>
<p>在book表中的year_publication字段上建立普通索引，SQL语句如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE book(</span><br><span class="line">book_id INT ,</span><br><span class="line">book_name VARCHAR(100),</span><br><span class="line">authors VARCHAR(100),</span><br><span class="line">info VARCHAR(100) ,</span><br><span class="line">comment VARCHAR(100),</span><br><span class="line">year_publication YEAR,</span><br><span class="line">INDEX(year_publication)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>创建唯一索引</li>
</ol>
<p>举例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test1(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">name varchar(30) NOT NULL,</span><br><span class="line">UNIQUE INDEX uk_idx_id(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test1 \G</span><br></pre></td></tr></table></figure>



<ol start="3">
<li>主键索引</li>
</ol>
<p>设定为主键后数据库会自动建立索引，innodb为聚簇索引，语法:</p>
<ul>
<li>随表一起建索引:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">  id INT(10) UNSIGNED  AUTO_INCREMENT ,</span><br><span class="line">  student_no VARCHAR(200),</span><br><span class="line">  student_name VARCHAR(200),</span><br><span class="line">  PRIMARY KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>删除主键索引:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE student</span><br><span class="line">drop PRIMARY KEY ;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改主键索引:必须先删除掉(drop)原索引，再新建(add)索引</li>
</ul>
<ol start="4">
<li>创建单列索引</li>
</ol>
<p>举例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test2(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">name CHAR(50) NULL,</span><br><span class="line">INDEX single_idx_name(name(20))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test2 \G</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>创建组合索引</li>
</ol>
<p>举例:创建表test3，在表中的id、name和age字段上建立组合索引，SQL语句如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test3(</span><br><span class="line">id INT(11) NOT NULL,</span><br><span class="line">name CHAR(30) NOT NULL,</span><br><span class="line">age INT(11) NOT NULL,</span><br><span class="line">info VARCHAR(255),</span><br><span class="line">INDEX multi_idx(id,name,age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>该语句执行完毕之后，使用SHOW INDEX 查看:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW INDEX FROM test3 \G</span><br></pre></td></tr></table></figure>



<ol start="6">
<li>创建全文索引</li>
</ol>
<p>举例1:创建表test4，在表中的info字段上建立全文索引，SQL语句如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test4(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">name CHAR(30) NOT NULL,</span><br><span class="line">age INT NOT NULL,</span><br><span class="line">info VARCHAR(255),</span><br><span class="line">FULLTEXT INDEX futxt_idx_info(info)</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>

<p>举例2:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE articles (</span><br><span class="line">    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,</span><br><span class="line">    title VARCHAR (200),</span><br><span class="line">    body TEXT,</span><br><span class="line">    FULLTEXT index (title, body)</span><br><span class="line">) ENGINE = INNODB ;</span><br></pre></td></tr></table></figure>

<p>创建了一个给title和body字段添加全文索引的表。</p>
<p>举例3:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `papers` (</span><br><span class="line">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `title` varchar(200) DEFAULT NULL,</span><br><span class="line">  `content` text,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  FULLTEXT KEY `title` (`title`,`content`)</span><br><span class="line">) ENGINE=MyISAM DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>不同于like方式的的查询:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM papers WHERE content LIKE ‘%查询字符串%’;</span><br></pre></td></tr></table></figure>

<p>全文索引用match+against方式查询:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM papers WHERE MATCH(title,content) AGAINST (‘查询字符串’);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意点</p>
</blockquote>
<ol>
<li><p>使用全文索引前，搞清楚版本支持情况;</p>
</li>
<li><p>全文索引比 like + % 快 N 倍，但是可能存在精度问题;</p>
</li>
<li><p>如果需要全文索引的是大量数据，建议先添加数据，再创建索引</p>
</li>
<li><p>创建空间索引</p>
</li>
</ol>
<p>空间索引创建中，要求空间类型的字段必须为 <strong>非空</strong> 。</p>
<p> 举例:创建表test5，在空间类型为GEOMETRY的字段上创建空间索引，SQL语句如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test5(</span><br><span class="line">geo GEOMETRY NOT NULL,</span><br><span class="line">SPATIAL INDEX spa_idx_geo(geo)</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>





<p>在已经存在的表上创建索引:</p>
<p>在已经存在的表中创建索引可以使用ALTER TABLE语句或者CREATE INDEX语句。</p>
<ol>
<li>使用ALTER TABLE语句创建索引 ALTER TABLE语句创建索引的基本语法如下:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY]</span><br><span class="line">[index_name] (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用CREATE INDEX创建索引 CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中， CREATE INDEX被映射到一个ALTER TABLE语句上，基本语法结构为:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name</span><br><span class="line">ON table_name (col_name[length],...) [ASC | DESC]</span><br></pre></td></tr></table></figure>





<blockquote>
<p> 删除索引</p>
</blockquote>
<ol>
<li>使用ALTER TABLE删除索引 ALTER TABLE删除索引的基本语法格式如下:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name DROP INDEX index_name;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用DROP INDEX语句删除索引 DROP INDEX删除索引的基本语法格式如下:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP INDEX index_name ON table_name;</span><br></pre></td></tr></table></figure>

<p>提示: 删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成 索引的所有列都被删除，则整个索引将被删除。</p>
<h3 id="4-6-索引的设计原则"><a href="#4-6-索引的设计原则" class="headerlink" title="4.6 索引的设计原则"></a>4.6 索引的设计原则</h3><blockquote>
<p>适合创建索引的情况</p>
</blockquote>
<ul>
<li>唯一性约束的字段</li>
<li>频繁使用where查询的字段</li>
<li>经常GROUP BY 和 ORDER BY 的列</li>
<li>UPDATE，DELETE 时的 where 条件列</li>
<li>DISTINCT的字段</li>
<li>多表JOIN连接时创建索引注意<ul>
<li>连接表的数量尽量不超过3张，每加一张表就相当于嵌套一次循环</li>
<li>对 where 条件创建索引</li>
<li>用于连接的字段创建索引</li>
</ul>
</li>
</ul>
<ul>
<li>尽量给数据类型小的列添加索引，节省空间，让一页存在更多记录，比较速度页更快</li>
<li>使用区分度高的列作为索引</li>
<li>联合索引时，使用最频繁的列放在联合索引的左侧</li>
</ul>
<blockquote>
<p>不适合创建索引的情况</p>
</blockquote>
<ul>
<li><p>where，group by ，orderby 条件使用不到的字段不要加索引</p>
</li>
<li><p>数据量小的表不要添加索引</p>
</li>
<li><p>有大量重复数据的列不要添加索引</p>
</li>
<li><p>经常更新的表尽量少创建索引</p>
</li>
<li><p>不建议使用无序的值作为索引</p>
</li>
<li><p>不再使用或很少使用的索引及时删除</p>
</li>
</ul>
<h3 id="4-7-索引失效场景"><a href="#4-7-索引失效场景" class="headerlink" title="4.7 索引失效场景"></a>4.7 索引失效场景</h3><ol>
<li><strong>最佳左前缀规则</strong></li>
</ol>
<ul>
<li>在MySQL建立联合索引时会遵守最佳左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</li>
<li>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结论：MySQL可以为多个字段创建索引，一个索引可以包括16个字段(默认)。对于多列索引，过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后面的字段都无法被使用。如果查询条件中没有使用这些字段中第1个字段时，多列(或联合)索引不会被使用。</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>主键插入顺序</strong></li>
</ol>
<ul>
<li>对于一个使用InnoDB存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在<code>聚簇索 引的叶子节点的。</code></li>
<li>而记录又是存储在数据页中的，数据页和记录又是<code>按照记录主键值从小到大的顺序进行排序</code>，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插</li>
<li>而如果我们插入的主键值忽大忽小的话，就会造成把一条数据插入一个已经满了的数据页，<code>产生页分裂</code>，造成性能损耗，所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增。</li>
</ul>
<ol start="3">
<li><strong>计算，函数，类型转换导致索引失效</strong></li>
</ol>
<p>比如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = &#x27;abc&#x27;; </span><br><span class="line"></span><br><span class="line">SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno+1 = 900001;</span><br><span class="line"># NAME 为VARCHAR，转成 123 int</span><br><span class="line">SELECT SQL_NO_CACHE * FROM student WHERE NAME = 123; </span><br></pre></td></tr></table></figure>

<p>这种SQL必须经过全表扫描，然后才能那每条数据来计算转换，根本使用不到索引</p>
<ol start="4">
<li><strong>范围条件右边的列索引失效</strong></li>
</ol>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># age,classId,NAME 联合索引</span><br><span class="line">CREATE INDEX idx_age_classId_name ON student(age,classId,NAME);</span><br><span class="line"></span><br><span class="line">SELECT SQL_NO_CACHE * FROM student </span><br><span class="line">WHERE student.age=30 AND student.classId&gt;20 AND student.name = &#x27;abc&#x27; ; </span><br></pre></td></tr></table></figure>

<p>下边这条查询语句就只能用到age,classId索引，name就没有用到，<code>因为 classId&gt;20 为范围条件</code>，它右边的索引列会失效。</p>
<p><strong>所以在创建索引时，务必把涉及范围查找的字段放在最后</strong></p>
<ol start="5">
<li><strong>不等于索引失效</strong></li>
</ol>
<p>这个很简单，对于不等于查询，我们只能一个个比较，使用不到索引</p>
<ol start="6">
<li><strong>is null可以使用索引，is not null无法使用索引</strong></li>
</ol>
<p>和等于不等于有点像，is null 就相当于等于，is not null 就相当于不等于</p>
<p><strong>结论：最好在设计数据表的时候就将字段设置为NOT NULL约束，如果有些字段就是要为null，可以设置默认值，比如你可以将 INT 类型的字段，默认值设置为0，将字符类型的默认值设置为空字符串(‘’)。</strong></p>
<ol start="7">
<li><strong>like以通配符%开头索引失效</strong></li>
</ol>
<p>like以确定字符开头，是可以使用索引的，但是以通配符%开头无法使用，因为它上来就不知道怎么查，就只能先全表查了</p>
<ol start="8">
<li><strong>OR 前后存在非索引的列，索引失效</strong></li>
</ol>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># age 索引</span><br><span class="line">CREATE INDEX idx_age ON student(age);</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age = 10 OR classid = 100;</span><br></pre></td></tr></table></figure>

<p>下边这条查询语句，一个有索引，一个没索引，OR 还是要全表扫描，索性就没有用。</p>
<h3 id="4-8-关联查询、子查询和排序相关优化"><a href="#4-8-关联查询、子查询和排序相关优化" class="headerlink" title="4.8 关联查询、子查询和排序相关优化"></a>4.8 关联查询、子查询和排序相关优化</h3><blockquote>
<p>关联查询优化</p>
</blockquote>
<p>情况1：左外连接(和右外连接相似)</p>
<p>对于左外连接来说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SQL_NO_CACHE * FROM a LEFT JOIN b ON a.字段 = b.字段;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果不加索引，他们两个表都会进行全表扫描，MySQL会自动使用上<code>缓存</code>提高效率。</li>
</ul>
<ul>
<li>如果只添加一个索引，一定要<code>给被驱动表</code>，也就是 b 表加， 因为 a 为主表，无论加与不加都会全表扫描出来。</li>
<li>但 a，b 表的那俩条件字段一定要相同类型，否则<code>类型转换</code>会导致索引失效。</li>
</ul>
<p>情况2：内连接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SQL_NO_CACHE * FROM a INNER JOIN b ON a.字段 = b.字段;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于内连接来说，查询优化器可以决定谁作为驱动表，谁作为被驱动表出现的</li>
<li>如果表的连接条件中只能有一个字段有索引，则有索引的字段所在的表会被作为被驱动表出现。</li>
<li>在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。<code>小表驱动大表</code></li>
</ul>
<blockquote>
<p>join语句原理</p>
</blockquote>
<ul>
<li><p>JOIN 方式连接多个表，本质是各个表之间数据的<code>循环匹配</code>。</p>
</li>
<li><p>MySQL5.5版本之前，MySQL只支持一种表间关联方式，就是<code>嵌套循环</code>(Nested Loop Join)。如果关联表的数据量很大，则 JOIN 关联的执行时间会非常长。</p>
</li>
<li><p>在MySQL5.5以后的版本中，MySQL通过引入BNLJ算法来优化嵌套执行。</p>
</li>
</ul>
<p>如下：</p>
<ul>
<li>驱动表就是主表，被驱动表就是从表、非驱动表。</li>
<li>简单嵌套循环<ul>
<li>两个表都没有索引，每次从主表A取一条数据，遍历从表B匹配，将匹配到的数据放到 result</li>
</ul>
</li>
</ul>
<ul>
<li><p>索引嵌套循环</p>
<ul>
<li><p>其优化的思路主要是<code>为了减少内层表数据的匹配次数</code>，所以要求被驱动表上必须有索引才行。</p>
</li>
<li><p>通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录去进行比较，这样极大的减少了对内层表的匹配次数。</p>
</li>
<li><p>如果被驱动表加索引，效率是非常高的，但如果索引不是主键索引，所以还得进行一次<code>回表</code>查询。相比，<code>被驱动表的索引是主键索引，效率会更高</code>。</p>
</li>
</ul>
</li>
<li><p>块嵌套循环连接</p>
<ul>
<li><p>如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把被驱动表的记录在加载到内存匹配，这样周而复始，<code>大大增加了1O的次数</code>。</p>
</li>
<li><p>为了减少被驱动表的IO次数，就出现了块嵌套循环连接的方式。</p>
</li>
</ul>
<ul>
<li>不再是逐条获取驱动表的数据，而是一块一块的获取，引入了join buffer缓冲区，将驱动表join相关的部分数<br>据列大小缓存到join bufferr中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和join buffer中的所有驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。<br><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230703102832651.png" alt="image-20230703102832651"></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">缓存时不光缓存关联表的列，select 的列也会缓存起来，所以，查询时尽量减少不必要的字段。`</span><br><span class="line">`注意：小表驱动大表的含义——小的结果集驱动大的结果集，为了减少内存循环次数。</span><br></pre></td></tr></table></figure>

<p>从MySQL8.0开始，废弃了BNLJ（块嵌套查询），加入了 hash join，hash join是大数据集连接时的常用方式，但他只能应用于等值连接。</p>
<blockquote>
<p>子查询优化</p>
</blockquote>
<ul>
<li>使用子查询可以进行SELECT语句的<code>嵌套查询</code>，即一个SELECT查询的结果作为另一个SELECT语句的条件。</li>
<li>子查询可以<code>一次性完成很多逻辑上需要多个步骤才能完成的SQL操作</code>。</li>
</ul>
<ul>
<li><p>子查询是MySQL的一项重要的功能，可以帮助我们通过一个SQL语句实现比较复杂的查询。但是，子查询的执行效率不高。原因：</p>
<ul>
<li>①执行子查询时，MySQL需要为内层查询语句的查询结果建立一个<code>临时表</code>，然后外层查询语句从临时表中查询记录。查询完毕后，再<code>撤销这些临时表</code>。这样会消耗更多的CPU和I&#x2F;O资源，产生大量的慢查询。</li>
<li>②子查询的结果集存储的临时表，<code>不论是内存临时表还是磁盘临时表都不会存在索引</code>，所以查询性能会受到一定的影响。</li>
<li>③对于返回结果集比较大的子查询，其对查询性能的影响也就越大。</li>
</ul>
</li>
<li><p>在MySQL中，可以使用连接（JOIN）查询来替代子查询。<code>连接查询不需要建立临时表</code>，其速度比子查询要快，如果查询中使用索引的话，性能就会更好。</p>
</li>
</ul>
<blockquote>
<p>排序相关优化</p>
</blockquote>
<p>问题：WHERE条件上加了索引，为什么还要在 ORDER BY字段加索引？</p>
<ul>
<li>在MySQL中，支持两种排序方式，分别是 FileSort 和 Index 排序。</li>
<li>lndex排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高。</li>
<li>FileSort排序则一般在内存中进行排序，占用CPU较多。如果待排结果较大，会产生临时文件I&#x2F;O到磁盘进行排序的情况，效率较低。</li>
</ul>
<p>优化建议：</p>
<ol>
<li>SQL中，可以在 WHERE 子句 和 ORDER BY 子句中使用索引，目的是在 WHERE 子句中避免全表扫描，在ORDER BY子句避免使用 FileSort 排序。</li>
<li>尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列,如果不同就使用联合索引。</li>
<li>无法使用lndex时，需要对 FileSort 方式进行调优。</li>
</ol>
<p><strong>其实具体是否使用索引，还是由优化器根据数据量计算决定的，我们添加索引，最起码是提供了一种方案。</strong></p>
<p><strong>总之，在两个索引同时存在时，MySQL会自动选择最优的方案，但是，随着数据量的变化，选择的索引也会随之变化。</strong><br><strong>当 范围条件 和 GROUP BY 或者 ORDER BY 字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的足够多，而需要排序的数据不多时，优先把索引放在范围字段，反之亦然。</strong></p>
<blockquote>
<p>优化Group by</p>
</blockquote>
<ul>
<li>group by使用索引的原则几乎跟order by一致，group by即使没有过滤条件用到索引，也可以直接使用索引。</li>
<li>group by 先排序再分组，遵照索引建的最佳左前缀法则</li>
<li>where效率高于having，能写在where限定的条件就不要写在having中了</li>
<li>减少使用order by，能不排序就不排序，或将排序放到程序端去做。Order by、group by、distinct 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li>
<li>包含了order by、group by、distinct这些查询的语句，where条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li>
</ul>
<h3 id="4-9-覆盖索引"><a href="#4-9-覆盖索引" class="headerlink" title="4.9 覆盖索引"></a>4.9 覆盖索引</h3><blockquote>
<p> 什么是覆盖索引?</p>
</blockquote>
<ul>
<li><p>解释一:</p>
<ul>
<li><p>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。</p>
</li>
<li><p><strong>毕竟索引叶子节点存储了它们索引的数据，当能通过读取索引就可以得到想要的数据时，那就不需要回表了。</strong><br><strong>一个索引包含了满足查询结果的数据就叫做覆盖索引。</strong></p>
</li>
<li><p>覆盖索引一定是二级索引</p>
</li>
</ul>
</li>
<li><p>解释二：</p>
<ul>
<li><code>非聚簇复合索引的一种形式</code>，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列（即建索引的字段正好是覆盖查询条件中所涉及的字段）。<br>简单说就是，索引列＋主键包含SELECT到FROM之间查询的列。</li>
</ul>
</li>
</ul>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># id为主键，创建一个age,NAME联合索引</span><br><span class="line">CREATE INDEX idx_age_name ON student (age,NAME);</span><br><span class="line"></span><br><span class="line"># 前边我们学习过，不等于会使索引失效，但是下边会打破这个规则，因为优化器根据执行成本选择到底使不使用</span><br><span class="line"></span><br><span class="line"># 这条语句就用不到索引，因为 SELECT * ，反之会回表操作，就没有必要使用索引了</span><br><span class="line">EXPLAIN SELECT * FROM student WHERE age &lt;&gt; 20;</span><br><span class="line"></span><br><span class="line"># 这条就可以，因为查询的字段刚好就是索引字段，不需要回表</span><br><span class="line">EXPLAIN SELECT age,NAME FROM student WHERE age &lt;&gt; 20;</span><br></pre></td></tr></table></figure>



<blockquote>
<p> 覆盖索引的好处</p>
</blockquote>
<p><strong>避免lnnodb表进行索引的二次查询（回表）</strong></p>
<ul>
<li>lnnodb是以聚集索引的顺序来存储的，对于lnnodb来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据，在查找到相应的键值后，还需通过主键进行二次查询才能获取我们真实所需要的数据。</li>
<li>在覆盖索引中，二级索引的键值中可以获取所要的数据，<strong>避免了对主键的二次查询</strong>，减少了IO操作，提升了查询效率</li>
</ul>
<p><strong>可以把随机 IO 变成顺序 IO 加快查询效率</strong></p>
<ul>
<li>由于覆盖索引是按键值的顺序存储的，对于IO密集型的范围查找来说，比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的IO转变成索引查找的顺序IO。</li>
</ul>
<p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p>
<h3 id="4-10-索引下推"><a href="#4-10-索引下推" class="headerlink" title="4.10 索引下推"></a>4.10 索引下推</h3><p>举例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># key1是索引，如下查询</span><br><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key1 LIKE &#x27;%a&#x27;;</span><br></pre></td></tr></table></figure>

<ul>
<li>按照我们之前的学习，like以通配符%开头索引失效，应该是先用索引查询条件 key1 &gt; ‘z’，然后进行回表，在查到的记录中在查找条件 key1 LIKE ‘%a’</li>
<li>其实并不是的，优化器会 <strong>先用索引查询条件 key1 &gt; ‘z’，不回表，继续在这些索引中过滤条件 key1 LIKE ‘%a’，最后只回表一次，这就是索引条件下推。</strong></li>
</ul>
<p>ICP 默认是开启的，可以选择手动关闭</p>
<blockquote>
<p>ICP的使用条件</p>
</blockquote>
<ul>
<li>如果表访问的类型为range、ref、eq＿ref 和 ref＿or＿null 可以使用ICP</li>
<li>ICP可以用于 InnoDB 和 MyISAM 表，包括分区表 InnoDB 和 MyISAM 表</li>
<li>对于InnoDB表，ICP仅用于二级索引。I<strong>CP的目标是减少全行读取次数，从而减少I／O操作。</strong></li>
<li><strong>当SQL使用覆盖索引时，不支持ICP</strong>。因为这种情况下使用ICP不会减少 I&#x2F;O。</li>
<li>相关子查询的条件不能使用ICP。</li>
</ul>
<h3 id="4-11-其他相关策略"><a href="#4-11-其他相关策略" class="headerlink" title="4.11 其他相关策略"></a>4.11 其他相关策略</h3><blockquote>
<p>普通索引vs唯一索引</p>
</blockquote>
<p>假设，执行查询的语句是 select id from test where k&#x3D;5。</p>
<p>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一 个不满足k&#x3D;5条件的记录。 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检 索。</p>
<p>那么，这个不同带来的性能差距会有多少呢?答案是， 微乎其微 。</p>
<blockquote>
<p>EXISTS 和 IN的选择</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A WHERE cc IN（SELECT cc FROM B）</span><br><span class="line"></span><br><span class="line">SELECT * FROM A WHERE EXISTS(SELECT cc FROM B WHERE B．cc＝A．cc)</span><br></pre></td></tr></table></figure>

<ul>
<li>当 A 小于 B 时，使用 EXISTS，因为 EXISTS 执行相当于一个嵌套循环，每次拿 A 的一条数据，去 B 里边循环比较。</li>
<li>当 B小于 A 时，使用 IN，因为 B 表较小，IN先计算出 IN 中语句的结果，然后外层直接精确匹配。</li>
</ul>
<p><strong>总结就是：小表驱动大表</strong></p>
<blockquote>
<p>COUNT(*) ，COUNT(1) 和 COUNT(字段)</p>
</blockquote>
<ul>
<li>COUNT(*) 和 COUNT(1)<ul>
<li>这两本质上没有什么区别，执行效率相差不多。</li>
<li>如果是在 MyISAM 中，统计表行数只需要O(1)复杂度，因为每张 MyISAM 表都有一个 meta 存储了row_count。</li>
<li>如果是InnoDB，需要全表扫描，因为 它支持事物，采用行级锁和MVCC机制，无法维护row_count，时间复杂度是O(n)。</li>
</ul>
</li>
</ul>
<ul>
<li>COUNT(字段)<ul>
<li>在 InnoDB 中，<code>要尽量采用二级索引</code>，因为聚簇索引包含信息较多。</li>
<li>对于COUNT(*) 和 COUNT(1)，其实系统会自动选择较小的二级索引来统计。</li>
</ul>
</li>
</ul>
<blockquote>
<p> 关于SELECT(*)</p>
</blockquote>
<ul>
<li>不建议使用：<ul>
<li>MySQL在解析的过程中，会<code>通过查询数据字典将 “ * ” 按序转换成所有列名</code>，这会大大的耗费资源和时间。</li>
<li>无法使用覆盖索引。</li>
</ul>
</li>
</ul>
<blockquote>
<p>关于LIMIT 1</p>
</blockquote>
<ul>
<li>针对的是会扫描全表的SQL语句，如果你可以确定结果集只有一条，那么加上 LIMIT 1 的时候，当找到一条结果的时候就不会继续扫描了，这样会加快查询速度。</li>
<li>如果数据表已经对字段建立了唯一索引，那么可以通过索引进行查询，不会全表扫描的话，就不需要加上LIMIT 1了。</li>
</ul>
<h2 id="五、性能分析工具使用"><a href="#五、性能分析工具使用" class="headerlink" title="五、性能分析工具使用"></a>五、性能分析工具使用</h2><h3 id="5-1-数据库服务器的优化步骤"><a href="#5-1-数据库服务器的优化步骤" class="headerlink" title="5.1 数据库服务器的优化步骤"></a>5.1 数据库服务器的优化步骤</h3><p>当我们遇到数据库调优问题的时候，该如何思考呢？这里把思考的流程整理成下面这张图。</p>
<p>整个流程划分成了<code>观察（Show status）</code>和<code>行动（Action）</code>两个部分。字母 S 的部分代表观察（会使用相应的分析工具），字母 A 代表的部分是行动（对应分析可以采取的行动）。</p>
<img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230703091218885.png" alt="image-20230703091218885" style="zoom:67%;">

<p>我们可以通过观察了解数据库整体的运行状态，通过性能分析工具可以让我们了解执行慢的SQL都有哪些，查看具体的SQL执行计划，甚至是SQL执行中的每一步的成本代价，这样才能定位问题所在，找到了问题，再采取相应的行动。</p>
<p><strong>详细解释一下这张图:</strong></p>
<p>首先在S1部分，我们需要观察服务器的状态是否存在周期性的波动。如果<code>存在周期性波动</code>，有可能是周期性节点的原因，比如双十一、促销活动等。这样的话，我们可以通过A1这一步骤解决，也就是加缓存，或者更改缓存失效策略。</p>
<p>如果缓存策略没有解决，或者不是周期性波动的原因，我们就需要进一步<code>分析查询延迟和卡顿的原因</code>。接下来进入<br>S2这一-步，我们需要<code>开启慢查询</code>。慢查询可以帮我们定位执行慢的SQL语句。我们可以通过设置<code>long_query_time</code>参数定义“慢”的阈值，如果SQL执行时间超过了<code>long_query_time</code>，则会认为是慢查询。当收集上来这些慢查询之后，我们就可以通过分析工具对慢查询日志进行分析。</p>
<p>在S3这一步骤中，我们就知道了执行慢的SQL，这样就可以针对性地用<code>EXPLAIN</code>查看对应SQL语句的执行计划，或者使用<code>show profile</code>查看SQL中每一个步骤的时间成本。这样我们就可以了解SQL查询慢是因为执行时间长，还是等待时间长。</p>
<p>​    如果是SQL等待时间长，我们进入A2步骤。在这一步骤中，我们可以<code>调优服务器的参数</code>，比如适当增加数据库缓冲池等。如果是SQL执行时间长，就进入A3步骤，这一步中我们需要考虑是索引设计的问题?还是查询关联的数据表过多?还是因为数据表的字段设计问题导致了这一现象。然后在这些维度上进行对应的调整。</p>
<p>如果A2和A3都不能解决问题，我们需要考虑数据库自身的SQL查询性能是否已经达到了瓶颈，如果确认没有达到性能瓶颈，就需要重新检查，重复以上的步骤。如果已经达到了<code>性能瓶颈</code>，进入A4阶段，需要考虑<code>增加服务器</code>，采用读写分离的架构，或者考虑对数据库进行<code>分库分表</code>，比如垂直分库、垂直分表和水平分表等。</p>
<p>以上就是数据库调优的流程思路。如果我们发现执行SQL时存在不规则延迟或卡顿的时候，就可以采用分析工具帮我们定位有问题的SQL，这三种分析工具你可以理解是SQL调优的三个步骤:<code>慢查询、</code> <code>EXPLAIN</code>和 <code>SHOWPROFILING</code>。</p>
<p><strong>小结：</strong></p>
<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220325180029352.png" alt="image-20220325180029352"></p>
<h3 id="5-2-定位执行慢的-SQL：慢查询日志"><a href="#5-2-定位执行慢的-SQL：慢查询日志" class="headerlink" title="5.2 定位执行慢的 SQL：慢查询日志"></a>5.2 定位执行慢的 SQL：慢查询日志</h3><p>MySQL的慢查询日志，用来记录在MySQL中<code>响应时间超过阀值</code>的语句，具体指运行时间超过<code>long_query_time</code>值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为<code>10</code>，意思是运行10秒以上(不含10秒)的语句，认为是超出了我们的最大忍耐时间值。|</p>
<p>它的主要作用是，帮助我们发现那些执行时间特别长的SQL查询，并且有针对性地进行优化，从而提高系统的整体效率。当我们的数据库服务器发生阻塞、运行变慢的时候，检查一下慢查询日志，找到那些慢查询，对解决问题很有帮助。比如一条sq|执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合explain进行全面分析。</p>
<p>默认情况下，MySQL数据库<code>没有开启慢查询日志</code>，需要我们手动来设置这个参数。<strong>如果不是调优需要的话，一般不建议启动该参数</strong>，因为开启慢查询日志会或多或少带来一定的性能影响</p>
<p>慢查询日志支持将日志记录写入文件。</p>
<blockquote>
<p>开启慢查询日志参数</p>
</blockquote>
<p><strong>1.开启slow_query_log</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show variables like &#x27;%slow_query_log%&#x27;;</span><br><span class="line">mysql &gt; set global slow_query_log=&#x27;ON&#x27;;</span><br></pre></td></tr></table></figure>



<p>然后我们再来查看下慢查询日志是否开启，以及慢查询日志文件的位置：</p>
<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220325181405473.png" alt="image-20220325181405473"></p>
<p>你能看到这时慢查询分析已经开启，同时文件保存在 <code>/var/lib/mysql/atguigu02-slow.log</code> 文件<br>中。</p>
<p><strong>2. 修改long_query_time阈值</strong></p>
<p>接下来我们来看下慢查询的时间阈值设置，使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql &gt; show variables like &#x27;%long_query_time%&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220325181420603.png" alt="image-20220325181420603"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 测试发现：设置global的方式对当前session的long_query_time失效。对新连接的客户端有效。所以可以一并执行下述语句</span><br><span class="line">mysql&gt; set global long_query_time = 1 ;</span><br><span class="line">mysql&gt; show global variables like &#x27; %long-query_time% &#x27;;</span><br><span class="line"></span><br><span class="line"># 即更改global 也更改了session变量</span><br><span class="line">mysql&gt; set long_query_time=1;</span><br><span class="line">mysql&gt; show variables like &#x27;%long_query_time%&#x27;;  </span><br></pre></td></tr></table></figure>




<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220325181712981.png" alt="image-20220325181712981"></p>
<p><strong>补充:配置文件中一并设置参数</strong></p>
<p>如下的方式相较于前面的命令行方式，可以看作是永久设置的方式。</p>
<p>修改<code>my.cnf</code> 文件，<code>[mysqld]下</code>增加或修改参数<code>long_query_time</code>、<code>slow_query_log</code>和<code>slow_query_log_file</code>后，然后重启MySQL服务器。|</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="string">ON #开启慢查询日志的开关</span></span><br><span class="line"><span class="attr">slow_query_log_file</span>=<span class="string">/var/lib/mysql/my-slow.log #慢查询日志的目录和文件名信息</span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="string">3 #设置慢查询的阈值为3秒，超出此设定值的SQL即被记录到慢查询日志</span></span><br><span class="line"><span class="attr">log_output</span>=<span class="string">FILE</span></span><br></pre></td></tr></table></figure>

<p>如果不指定存储路径，查询日志将默认存储到MySQL数据库的数据文件夹下。如果不指定文件名，默认文件名为hostname-slow.log。</p>
<blockquote>
<p>查看慢查询数目</p>
</blockquote>
<p>查询当前系统中有多少条慢查询记录  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW GLOBAL STATUS LIKE &#x27;%Slow_queries%&#x27;;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>案例演示  </p>
</blockquote>
<p><strong>步骤1. 建表</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `student` (</span><br><span class="line">`id` INT(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`stuno` INT NOT NULL ,</span><br><span class="line">`name` VARCHAR(20) DEFAULT NULL,</span><br><span class="line">`age` INT(3) DEFAULT NULL,</span><br><span class="line">`classId` INT(11) DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>



<p><strong>步骤2：设置参数 log_bin_trust_function_creators</strong>  </p>
<p>创建函数，假如报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This function has none of DETERMINISTIC......</span><br></pre></td></tr></table></figure>

<p>命令开启：允许创建函数设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。</span><br></pre></td></tr></table></figure>

<p><strong>步骤3：创建函数</strong></p>
<p>随机产生字符串：（同上一章）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_string(n INT)</span><br><span class="line">	RETURNS VARCHAR(255) #该函数会返回一个字符串</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE chars_str VARCHAR(100) DEFAULT</span><br><span class="line">    &#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">    DECLARE return_str VARCHAR(255) DEFAULT &#x27;&#x27;;</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">	WHILE i &lt; n DO</span><br><span class="line">        SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR(1+RAND()*52),1));</span><br><span class="line">        SET i = i + 1;</span><br><span class="line">	END WHILE;</span><br><span class="line">	RETURN return_str;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>产生随机数值：（同上一章）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#测试</span><br><span class="line">SELECT rand_string(10);</span><br><span class="line"></span><br><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT(11)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">SET i = FLOOR(from_num +RAND()*(to_num - from_num+1)) ;</span><br><span class="line">RETURN i;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line">#测试：</span><br><span class="line">SELECT rand_num(10,100);</span><br></pre></td></tr></table></figure>

<p><strong>步骤4：创建存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE insert_stu1( START INT , max_num INT )</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET autocommit = 0; #设置手动提交事务</span><br><span class="line">    REPEAT #循环</span><br><span class="line">    SET i = i + 1; #赋值</span><br><span class="line">    INSERT INTO student (stuno, NAME ,age ,classId ) VALUES</span><br><span class="line">    ((START+i),rand_string(6),rand_num(10,100),rand_num(10,1000));</span><br><span class="line">    UNTIL i = max_num</span><br><span class="line">    END REPEAT;</span><br><span class="line">    COMMIT; #提交事务</span><br><span class="line">END //</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p><strong>步骤5：调用存储过程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#调用刚刚写好的函数, 4000000条记录,从100001号开始</span><br><span class="line"></span><br><span class="line">CALL insert_stu1(100001,4000000);</span><br></pre></td></tr></table></figure>





<blockquote>
<p>测试</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM student WHERE stuno = 3455655;</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">|    id   |  stuno  |  name  |  age | classId |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| 3523633 | 3455655 | oQmLUr |  19  |    39   |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">1 row in set (2.09 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM student WHERE name = &#x27;oQmLUr&#x27;;</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">|    id   |  stuno  |  name  |  age | classId |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line">| 1154002 | 1243200 | OQMlUR |  266 |   28    |</span><br><span class="line">| 1405708 | 1437740 | OQMlUR |  245 |   439   |</span><br><span class="line">| 1748070 | 1680092 | OQMlUR |  240 |   414   |</span><br><span class="line">| 2119892 | 2051914 | oQmLUr |  17  |   32    |</span><br><span class="line">| 2893154 | 2825176 | OQMlUR |  245 |   435   |</span><br><span class="line">| 3523633 | 3455655 | oQmLUr |  19  |   39    |</span><br><span class="line">+---------+---------+--------+------+---------+</span><br><span class="line"></span><br><span class="line">6 rows in set (2.39 sec)</span><br></pre></td></tr></table></figure>

<p>从上面的结果可以看出来，查询学生编号为“3455655”的学生信息花费时间为2.09秒。查询学生姓名为“oQmLUr”的学生信息花费时间为2.39秒。已经达到了秒的数量级，说明目前查询效率是比较低的，下面<br>的小节我们分析一下原因  。</p>
<p><strong>2.分析</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &#x27;slow_queries&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>补充说明:</strong></p>
<p>除了上述变量，控制慢查询日志的还有一个系统变量: min_examined_row_limit。这个变量的意思是，查询<code>扫描过的最少记录数</code>。这个变量和查询执行时间，共同组成了判别一个查询是否是慢查询的条件。如果查询扫描过的记录数大于等于这个变量的值，并且查询执行时间超过long_query_time的值，那么，这个查询就被记录到慢查询日志中; 反之，则不被记录到慢查询日志中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;min%&#x27;;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| min_examined_row_limit | 0     |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>你也可以根据需要，通过修改“my.ini”文件，来修改”min_examined_row_limit”的值。</p>
</blockquote>
<blockquote>
<p>慢查询日志分析工具：mysqldumpslow</p>
</blockquote>
<p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具<code>mysqldumpslow</code> 。</p>
<p>查看mysqldumpslow的帮助信息  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow --help</span><br></pre></td></tr></table></figure>



<p>mysqldumpslow 命令的具体参数如下：</p>
<ul>
<li>-a: 不将数字抽象成N，字符串抽象成S</li>
<li><strong>-s: 是表示按照何种方式排序：</strong><ul>
<li>c: 访问次数</li>
<li>l: 锁定时间</li>
<li>r: 返回记录</li>
<li><strong>t: 查询时间</strong></li>
<li>al:平均锁定时间</li>
<li>ar:平均返回记录数</li>
<li>at:平均查询时间 （默认方式）</li>
<li>ac:平均查询次数</li>
</ul>
</li>
<li><strong>-t: 即为返回前面多少条的数据；</strong>  </li>
<li><strong>-g: 后边搭配一个正则匹配模式，大小写不敏感的</strong></li>
</ul>
<p>举例：我们想要按照查询时间排序，查看前五条 SQL 语句，这样写即可：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s t -t 5 /var/lib/mysql/atguigu01-slow.log</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@bogon ~]# mysqldumpslow -s t -t 5 /var/lib/mysql/atguigu01-slow.log</span><br><span class="line"></span><br><span class="line">Reading mysql slow query log from /var/lib/mysql/atguigu01-slow.log</span><br><span class="line">Count: 1 Time=2.39s (2s) Lock=0.00s (0s) Rows=13.0 (13), root[root]@localhost</span><br><span class="line">	SELECT * FROM student WHERE name = &#x27;S&#x27;</span><br><span class="line"></span><br><span class="line">Count: 1 Time=2.09s (2s) Lock=0.00s (0s) Rows=2.0 (2), root[root]@localhost</span><br><span class="line">	SELECT * FROM student WHERE stuno = N</span><br><span class="line">	</span><br><span class="line">Died at /usr/bin/mysqldumpslow line 162, &lt;&gt; chunk 2.</span><br></pre></td></tr></table></figure>

<p><strong>工作常用参考：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#得到返回记录集最多的10个SQL</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line"></span><br><span class="line">#得到访问次数最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line"></span><br><span class="line">#得到按照时间排序的前10条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log</span><br><span class="line"></span><br><span class="line">#另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span><br></pre></td></tr></table></figure>



<blockquote>
<p>关闭慢查询日志  </p>
</blockquote>
<p><strong>除了调优需要开，正常还是不要开了</strong></p>
<p>MySQL服务器停止慢查询日志功能有两种方法：</p>
<p><strong>方式1：永久性方式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log=OFF</span><br></pre></td></tr></table></figure>

<p>或者，把slow_query_log一项注释掉 或 删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqld]</span><br><span class="line">#slow_query_log =OFF</span><br></pre></td></tr></table></figure>



<p>重启MySQL服务，执行如下语句查询慢日志功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%slow%&#x27;; #查询慢查询日志所在目录</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%long_query_time%&#x27;; #查询超时时长</span><br></pre></td></tr></table></figure>



<p><strong>方式2：临时性方式</strong>  </p>
<p>使用SET语句来设置。 （1）停止MySQL慢查询日志功能，具体SQL语句如下。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL slow_query_log=off;</span><br></pre></td></tr></table></figure>



<p>（2）<strong>重启MySQL服务</strong>，使用SHOW语句查询慢查询日志功能信息，具体SQL语句如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;%slow%&#x27;;</span><br><span class="line">#以及</span><br><span class="line">SHOW VARIABLES LIKE &#x27;%long_query_time%&#x27;;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>删除慢查询日志</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%slow_query_log%&#x27;;</span><br><span class="line">+---------------------+----------------------------+</span><br><span class="line">| Variable_name       | Value                      |</span><br><span class="line">+---------------------+----------------------------+</span><br><span class="line">| slow_query_log      | ON                         |</span><br><span class="line">| slow_query_log_file | /var/lib/mysql/my-slow.log |</span><br><span class="line">+---------------------+----------------------------+</span><br><span class="line">2 rows in set (0.07 se</span><br></pre></td></tr></table></figure>



<p>从执行结果可以看出，慢查询日志的目录默认为MySQL的数据目录，在该目录下<code>手动删除慢查询日志文件</code>即可。使用命令<code>mysqladmin flush-logs</code> 来重新生成查询日志文件，具体命令如下，执行完毕会在数据目录下重新生成慢查询日志文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 不使用这个命令，没办法自己创建</span><br><span class="line">mysqladmin -uroot -p flush-logs slow </span><br><span class="line"></span><br><span class="line">## 这个命令可以重置其他日志 例如undo日志</span><br></pre></td></tr></table></figure>



<blockquote>
<p>提示</p>
<p>慢查询日志都是使用mysqladmin flush-logs命令来删除重建的。使用时-定要注意，一旦执行了这个命令，慢<br>查询日志都只存在新的日志文件中，如果需要旧的查询日志，就必须事先备份。</p>
</blockquote>
<h3 id="5-3-分析查询语句：EXPLAIN"><a href="#5-3-分析查询语句：EXPLAIN" class="headerlink" title="5.3 分析查询语句：EXPLAIN"></a>5.3 分析查询语句：EXPLAIN</h3><blockquote>
<p>概述</p>
</blockquote>
<p><strong>定位了查询慢的SQL之后，我们就可以使用EXPLAIN或DESCRIBE工具做针对性的分析查询语句。</strong>DESCRIBE语句的使用方法与EXPLAIN语句是一样的，并且分析结果也是一样的。</p>
<p>MySQL中有专门负责优化SELECT语句的优化器模块，主要功能: 通过计算分析系统中收集到的统计信息，为客户端请求的Query提供它认为最优的<code>执行计划</code>（他认为最优的数据检索方式，但不见得是DBA认为是最优的，这部分最耗费时间)。</p>
<p>这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL为我们提供了<code>EXPLAIN</code>语句来帮助我们查看某个查询语句的具体执行计划，大家看懂<code>EXPLAIN</code>语句的各个输出项，可以有针对性的提升我们查询语句的性能。</p>
<p><strong>1.能做什么?</strong></p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的操作类型。</li>
<li>哪些索引可以使用</li>
<li><strong>哪些索引被实际使用</strong></li>
<li>表之间的引用</li>
<li><strong>每张表有多少行被优化器查询</strong></li>
</ul>
<p><strong>版本情况</strong></p>
<ul>
<li>MySQL 5.6.3以前只能 EXPLAIN SELECT ；MYSQL 5.6.3以后就可以 <code>EXPLAIN</code> <code>SELECT</code>，<code>UPDATE</code>，<code>DELETE</code></li>
<li>在5.7以前的版本中，想要显示 <code>partitions</code> 需要使用 <code>explain partitions</code> 命令；想要显示<code>filtered</code> 需要使用 <code>explain extended</code> 命令。在5.7版本后，默认explain直接显示partitions和filtered中的信息。</li>
</ul>
<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220325195048342.png" alt="image-20220325195048342"></p>
<blockquote>
<p>基本语法</p>
</blockquote>
<p>EXPLAIN 或 DESCRIBE语句的语法形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT select_options</span><br><span class="line"># 或者 两个是一样的</span><br><span class="line">DESCRIBE SELECT select_options</span><br></pre></td></tr></table></figure>



<p>如果我们想看看某个查询的执行计划的话，可以在具体的查询语句前边加一个 <code>EXPLAIN</code> ，就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT 1;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326113218648.png" alt="image-20220326113218648"></p>
<p><code>EXPLAIN</code> 语句输出的各个列的作用如下  </p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>在一个大的查询语句中每个SELECT关键字都对应一个 唯一的id</td>
</tr>
<tr>
<td>select_type</td>
<td>SELECT关键字对应的那个查询的类型</td>
</tr>
<tr>
<td>table</td>
<td>表名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区信息</td>
</tr>
<tr>
<td><strong>type</strong></td>
<td><strong>针对单表的访问方法</strong>（重要）</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td><strong>key</strong></td>
<td><strong>实际上使用的索引</strong></td>
</tr>
<tr>
<td><strong>key_len</strong></td>
<td><strong>实际使用到的索引长度</strong></td>
</tr>
<tr>
<td>ref</td>
<td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td><strong>rows</strong></td>
<td><strong>预估的需要读取的记录条数</strong></td>
</tr>
<tr>
<td>filtered</td>
<td>某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>一些额外的信 息</td>
</tr>
</tbody></table>
<blockquote>
<p>数据准备</p>
</blockquote>
<p><strong>1.建表</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE s1 (</span><br><span class="line">	id INT AUTO_INCREMENT,</span><br><span class="line">	key1 VARCHAR(100), </span><br><span class="line">	key2 INT, </span><br><span class="line">	key3 VARCHAR(100), </span><br><span class="line">	key_part1 VARCHAR(100),</span><br><span class="line">	key_part2 VARCHAR(100),</span><br><span class="line">	key_part3 VARCHAR(100),</span><br><span class="line">	common_field VARCHAR(100),</span><br><span class="line">	PRIMARY KEY (id),</span><br><span class="line">	INDEX idx_key1 (key1),</span><br><span class="line">	UNIQUE INDEX idx_key2 (key2),</span><br><span class="line">	INDEX idx_key3 (key3),</span><br><span class="line">	INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE=INNODB CHARSET=utf8;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE s2 (</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    key1 VARCHAR(100),</span><br><span class="line">    key2 INT,</span><br><span class="line">    key3 VARCHAR(100),</span><br><span class="line">    key_part1 VARCHAR(100),</span><br><span class="line">    key_part2 VARCHAR(100),</span><br><span class="line">    key_part3 VARCHAR(100),</span><br><span class="line">    common_field VARCHAR(100),</span><br><span class="line">    PRIMARY KEY (id),</span><br><span class="line">    INDEX idx_key1 (key1),</span><br><span class="line">    UNIQUE INDEX idx_key2 (key2),</span><br><span class="line">    INDEX idx_key3 (key3),</span><br><span class="line">	INDEX idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) ENGINE=INNODB CHARSET=utf8;</span><br></pre></td></tr></table></figure>





<p><strong>2. 设置参数 log_bin_trust_function_creators</strong></p>
<p>创建函数，假如报错，需开启如下命令：允许创建函数设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global log_bin_trust_function_creators=1; # 不加global只是当前窗口有效。</span><br></pre></td></tr></table></figure>

<p><strong>3. 创建函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE FUNCTION rand_string1 ( n INT ) </span><br><span class="line">	RETURNS VARCHAR ( 255 ) #该函数会返回一个字符串</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE</span><br><span class="line">		chars_str VARCHAR ( 100 ) DEFAULT &#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;;</span><br><span class="line">	DECLARE</span><br><span class="line">		return_str VARCHAR ( 255 ) DEFAULT &#x27;&#x27;;</span><br><span class="line">	DECLARE</span><br><span class="line">		i INT DEFAULT 0;</span><br><span class="line">	WHILE</span><br><span class="line">			i &lt; n DO</span><br><span class="line">			</span><br><span class="line">			SET return_str = CONCAT(</span><br><span class="line">				return_str,</span><br><span class="line">			SUBSTRING( chars_str, FLOOR( 1+RAND ()* 52 ), 1 ));</span><br><span class="line">		</span><br><span class="line">		SET i = i + 1;</span><br><span class="line">		</span><br><span class="line">	END WHILE;</span><br><span class="line">	RETURN return_str;</span><br><span class="line">	</span><br><span class="line">END // </span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>



<p><strong>4. 创建存储过程</strong></p>
<p>创建往s1表中插入数据的存储过程：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE insert_s1 (IN min_num INT (10),IN max_num INT (10))</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE i INT DEFAULT 0;</span><br><span class="line">    SET autocommit = 0;</span><br><span class="line">    REPEAT</span><br><span class="line">    SET i = i + 1;</span><br><span class="line">    INSERT INTO s1 VALUES(</span><br><span class="line">    (min_num + i),</span><br><span class="line">    rand_string1(6),</span><br><span class="line">    (min_num + 30 * i + 5),</span><br><span class="line">    rand_string1(6),</span><br><span class="line">    rand_string1(10),</span><br><span class="line">    rand_string1(5),</span><br><span class="line">    rand_string1(10),</span><br><span class="line">    rand_string1(10));</span><br><span class="line">    UNTIL i = max_num</span><br><span class="line">    END REPEAT;</span><br><span class="line">    COMMIT;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>创建往s2表中插入数据的存储过程：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE insert_s2 (IN min_num INT ( 10 ),IN max_num INT ( 10 )) </span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE i INT DEFAULT 0;</span><br><span class="line">	SET autocommit = 0;</span><br><span class="line">	REPEAT</span><br><span class="line"> 	SET i = i + 1;</span><br><span class="line">		INSERT INTO s2 VALUES(</span><br><span class="line">				( min_num + i ),</span><br><span class="line">				rand_string1 ( 6 ),</span><br><span class="line">				( min_num + 30 * i + 5 ),</span><br><span class="line">				rand_string1 ( 6 ),</span><br><span class="line">				rand_string1 ( 10 ),</span><br><span class="line">				rand_string1 ( 5 ),</span><br><span class="line">				rand_string1 ( 10 ),</span><br><span class="line">				rand_string1 ( 10 ));</span><br><span class="line">		UNTIL i = max_num </span><br><span class="line">	END REPEAT;</span><br><span class="line">	COMMIT;</span><br><span class="line">	</span><br><span class="line">END // </span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>



<p><strong>5. 调用存储过程</strong></p>
<p>s1表数据的添加：加入1万条记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL insert_s1(10001,10000); # id 10002~20001</span><br></pre></td></tr></table></figure>

<p>s2表数据的添加：加入1万条记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL insert_s2(10001,10000);# id 10002~20001</span><br></pre></td></tr></table></figure>





<blockquote>
<p>EXPLAIN各列作用</p>
</blockquote>
<p>为了让大家有比较好的体验，我们调整了下 <code>EXPLAIN</code> 输出列的顺序。</p>
<h4 id="1-table"><a href="#1-table" class="headerlink" title="1. table"></a>1. table</h4><p>表名</p>
<p>不论我们的查询语句有多复杂，里边儿 <code>包含了多少个表</code> ，到最后也是需要对每个表进行 <code>单表访问</code> 的，所<br>以MySQL规定<strong>EXPLAIN语句输出的每条记录都对应着某个单表的访问方法</strong>，该条记录的table列代表着该<br>表的表名（有时不是真实的表名字，可能是简称）  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#1. table：表名</span><br><span class="line">#查询的每一行记录都对应着一个单表</span><br><span class="line">explain select count(*) from s1;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326120805996-8347999.png" alt="image-20220326120805996"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#s1:驱动表  s2:被驱动表</span><br><span class="line">EXPLAIN SELECT * FROM s1 INNER JOIN s2;</span><br><span class="line"># 驱动表和被驱动表是 优化器决定的，他认为哪个比较好久用哪个</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326121611806-8347999.png" alt="image-20220326121611806"></p>
<blockquote>
<p>用到多少个表，就会有多少条记录</p>
</blockquote>
<h4 id="2-id"><a href="#2-id" class="headerlink" title="2. id"></a>2. id</h4><p>正常来说一个select 一个id ，也有例外的可能，查询优化器做了优化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326122616487.png" alt="image-20220326122616487"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326122717663.png" alt="image-20220326122717663"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326122751920.png" alt="image-20220326122751920"></p>
<p><strong>查询优化器优化</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">######查询优化器可能对涉及子查询的查询语句进行重写,转变为多表查询的操作########</span><br><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key2 FROM s2 WHERE common_field = &#x27;a&#x27;);</span><br></pre></td></tr></table></figure>

<p>运行结果： id 只有一个，原因是查询优化器做了优化</p>
<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326122857145.png" alt="image-20220326122857145"></p>
<p> <strong>Union去重</strong></p>
<p>原本想的1个select 一个 id , 预计两个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> #Union去重</span><br><span class="line"># union 去重，union all 不去重</span><br><span class="line">EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</span><br></pre></td></tr></table></figure>



<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326123056983.png" alt="image-20220326123056983"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># union all 不去重  所以不需要放在临时表里面</span><br><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326123147690.png" alt="image-20220326123147690"></p>
<p><strong>小结:</strong>  </p>
<ul>
<li>id如果相同，可以认为是一组，从上往下顺序执行</li>
<li>在所有组中，id值越大，优先级越高，越先执行</li>
<li>关注点：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</li>
</ul>
<h4 id="3-select-type"><a href="#3-select-type" class="headerlink" title="3. select_type"></a>3. select_type</h4><p>一条大的查询语句里边可以包含若干个SELECT关键字，<code>每个SELECT关键字代表着一个小的查询语句</code>，而每个SELECT关键字的FROM子句中都可以包含若干张表(这些表用来做连接查询)，<code>每一张表都对应着执行计划输出中的一条记录</code>，对于在同一个SELECT关键字中的表来说，它们的id值是相同的。</p>
<p>MySQL为每一个SELECT关键字代表的小查询都定义了一个称之为<code>select_type</code>的属性，意思是我们只要知道了某个小查询的<code>select_type属性</code>，就知道了这个<code>小查询在整个大查询中扮演了一个什么角色</code>，我们看一下<br><code>select_type</code>都能取哪些值，请看官方文档:</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>Simple  SELECT (not using UNION or subqueries)</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>Outermost  SELECT</td>
</tr>
<tr>
<td>UNION</td>
<td>Second  or later SELECT statement in a UNION</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>Result  of a UNION</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>First  SELECT in subquery</td>
</tr>
<tr>
<td>DEPENDENT     SUBQUERY</td>
<td>First  SELECT in subquery, dependent on outer query</td>
</tr>
<tr>
<td>DEPENDENT     UNION</td>
<td>Second  or later SELECT statement in a UNION, dependent on outer query</td>
</tr>
<tr>
<td>DERIVED</td>
<td>Derived  table</td>
</tr>
<tr>
<td>MATERIALIZED</td>
<td>Materialized  subquery</td>
</tr>
<tr>
<td>UNCACHEABLE     SUBQUERY</td>
<td>A  subquery for which the result cannot be cached and must be re-evaluated  for     each row of the outer query</td>
</tr>
<tr>
<td>UNCACHEABLE     UNION</td>
<td>The  second or later select in a UNION that belongs to an uncacheable  subquery     (see UNCACHEABLE SUBQUERY)</td>
</tr>
</tbody></table>
<ul>
<li><p><code>SIMPLE</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查询语句中不包含`UNION`或者子查询的查询都算作是`SIMPLE`类型</span><br><span class="line">EXPLAIN SELECT * FROM s1;</span><br><span class="line"></span><br><span class="line"> #连接查询也算是`SIMPLE`类型</span><br><span class="line">EXPLAIN SELECT * FROM s1 INNER JOIN s2;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>PRIMARY</code> 与 <code>UNION</code>与 <code>UNION RESULT</code></p>
<ul>
<li><p><code>UNION RESULT</code></p>
<p>MySQL选择使用临时表来完成<code>UNION</code>查询的去重工作，针对该临时表的查询的<code>select_type</code>就是<code>UNION RESULT</code>，例子上边有。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#对于包含`UNION`或者`UNION ALL`或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个</span><br><span class="line">#查询的`select_type`值就是`PRIMARY`</span><br><span class="line"> </span><br><span class="line">#对于包含`UNION`或者`UNION ALL`的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询</span><br><span class="line">#以外，其余的小查询的`select_type`值就是`UNION`</span><br><span class="line"></span><br><span class="line">#`MySQL`选择使用临时表来完成`UNION`查询的去重工作，针对该临时表的查询的`select_type`就是`UNION RESULT` 	</span><br></pre></td></tr></table></figure>



<p>测试sql:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;	</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326125611904.png" alt="image-20220326125611904"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 UNION ALL SELECT * FROM s2;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326125627303.png" alt="image-20220326125627303"></p>
</li>
<li><p><code>SUBQUERY</code></p>
<p>如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第个<code>SELECT</code> 关键字代表的那个查询<br>的<code>select_type</code>就是 <code>SUBQUERY</code>，比如下边这个查询:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#子查询：</span><br><span class="line">#如果包含子查询的查询语句不能够转为对应的`semi-join`的形式，并且该子查询是不相关子查询。</span><br><span class="line">#该子查询的第一个`SELECT`关键字代表的那个查询的`select_type`就是`SUBQUERY`</span><br><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326122751920.png" alt="image-20220326122751920"></p>
</li>
<li><p><code>DEPENDENT SUBQUERY</code></p>
<p>dependent subquery</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#如果包含子查询的查询语句不能够转为对应的`semi-join`的形式，并且该子查询是相关子查询，</span><br><span class="line">#则该子查询的第一个`SELECT`关键字代表的那个查询的`select_type`就是`DEPENDENT SUBQUERY`</span><br><span class="line">EXPLAIN SELECT * FROM s1 </span><br><span class="line">WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 = s2.key2) OR key3 = &#x27;a&#x27;;</span><br><span class="line">#注意的是，select_type为`DEPENDENT SUBQUERY`的查询可能会被执行多次。</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326130111650.png" alt="image-20220326130111650"></p>
</li>
<li><p><code>DEPENDENT UNION</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#在包含`UNION`或者`UNION ALL`的大查询中，如果各个小查询都依赖于外层查询的话，那除了</span><br><span class="line">#最左边的那个小查询之外，其余的小查询的`select_type`的值就是`DEPENDENT UNION`。</span><br><span class="line">EXPLAIN SELECT * FROM s1 </span><br><span class="line">WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = &#x27;a&#x27; UNION SELECT key1 FROM s1 WHERE key1 = &#x27;b&#x27;);</span><br><span class="line"></span><br><span class="line"># 这里优化器会重构成exist</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326130433291.png" alt="image-20220326130433291"></p>
</li>
<li><p><code>DERIVED</code></p>
<p>derived : 衍生，派生</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#对于包含`派生表`的查询，该派生表对应的子查询的`select_type`就是`DERIVED`</span><br><span class="line">EXPLAIN SELECT * </span><br><span class="line">FROM (SELECT key1, COUNT(*) AS c FROM s1 GROUP BY key1) AS derived_s1 WHERE c &gt; 1;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326141653065.png" alt="image-20220326141653065"></p>
</li>
<li><p><code>MATERIALIZED</code></p>
<p>materialized: 英 [məˈtɪəri:əˌlaɪzd] 具体化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，</span><br><span class="line">#该子查询对应的`select_type`属性就是`MATERIALIZED`</span><br><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2); #子查询被转为了物化表 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326142034981.png" alt="image-20220326142034981"></p>
<blockquote>
<p>不理解： 为啥上面的子查询，没有雾化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &#x27;a&#x27;;</span><br><span class="line"># 这个怎么不物化</span><br></pre></td></tr></table></figure>


</blockquote>
</li>
<li><p><code>UNCACHEABLE SUBQUERY</code></p>
<p>uncacheable </p>
</li>
<li><p><code>UNCACHEABLE UNION</code></p>
</li>
</ul>
<h4 id="4-partitions-可略"><a href="#4-partitions-可略" class="headerlink" title="4. partitions (可略)"></a>4. partitions (可略)</h4><ul>
<li>代表分区表中的命中情况，非分区表，该项为NULL。一般情况下我们的查询语句的执行计划的partitions列的值都是NULL。</li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/alter-table-partition-operations.html">https://dev.mysql.com/doc/refman/5.7/en/alter-table-partition-operations.html</a></li>
<li>如果想详细了解，可以如下方式测试。创建分区表：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 创建分区表，</span><br><span class="line">-- 按照id分区，id&lt;100 p0分区，其他p1分区</span><br><span class="line">CREATE TABLE user_partitions (</span><br><span class="line">    id INT auto_increment,</span><br><span class="line">    NAME VARCHAR(12),PRIMARY KEY(id))</span><br><span class="line">    PARTITION BY RANGE(id)(</span><br><span class="line">    PARTITION p0 VALUES less than(100),</span><br><span class="line">    PARTITION p1 VALUES less than MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC SELECT * FROM user_partitions WHERE id&gt;200;</span><br></pre></td></tr></table></figure>

<p>查询id大于200（200&gt;100，p1分区）的记录，查看执行计划，partitions是p1，符合我们的分区规则</p>
<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220325201510359.png" alt="image-20220325201510359"></p>
<h4 id="5-type-☆"><a href="#5-type-☆" class="headerlink" title="5. type ☆"></a>5. type ☆</h4><p>执行计划的一条记录就代表着MySQL对某个表的<code>执行查询时的访问方法</code>，又称”访问类型”，其中的<code>type</code>列就表明了这个访问方法是啥，是较为重要的一个指标。比如，看到<code>type</code>列的值是<code>ref</code>，表明MySQL即将使用<code>ref</code>访问方法来执行对<code>s1</code>表的查询。</p>
<p>完整的访问方法如下： <code>system</code> ， <code>const</code> ， <code>eq_ref</code> ， <code>ref</code> ， <code>fulltext</code> ， <code>ref_or_null</code> ，<code>index_merge</code> ， <code>unique_subquery</code> ， <code>index_subquery</code> ， <code>range</code> ， <code>index</code> ， <code>ALL</code> 。</p>
<p>我们详细解释一下：</p>
<ul>
<li><p><code>system</code>  </p>
<p>当表中<code>只有一条记录</code>并且该表使用的存储引擎的统计数据是精确的，比如MyISAM、Memory，那么对该表的访问方法就是<code>system</code>。比方说我们新建一个<code>MyISAM</code>表，并为其插入一条记录:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t(i int) Engine=MyISAM;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO t VALUES(1);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>然后我们看一下查询这个表的执行计划：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM t;</span><br><span class="line">+----+-------------+-------+------------+--------+</span><br><span class="line">| id | select_type | table | partitions | type   |</span><br><span class="line">+----+-------------+-------+------------+--------+</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | system |</span><br><span class="line">+----+-------------+-------+------------+--------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里如果是 innodb 会变成ALL ， 因为innodb系统不会存条数字段。。MyISAM会存储这么一个字段</p>
</blockquote>
</li>
<li><p><code>const</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#当我们根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是`const`</span><br><span class="line">EXPLAIN SELECT * FROM s1 WHERE id = 10005;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT * FROM s1 WHERE key2 = &#x27;10066&#x27;;</span><br></pre></td></tr></table></figure>




</li>
<li><p><code>eq_ref</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的</span><br><span class="line">#（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则</span><br><span class="line">#对该被驱动表的访问方法就是`eq_ref`</span><br><span class="line">EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;</span><br><span class="line">+----+------------+------+--------+---------+---------+------------------+------+</span><br><span class="line">| id | select_type| table| type   | key     | key_len | ref              | rows |</span><br><span class="line">+----+------------+------+--------+---------+---------+------------------+------+</span><br><span class="line">|  1 | SIMPLE     | s1   | ALL    | NULL    | NULL    | NULL             | 9895 |</span><br><span class="line">|  1 | SIMPLE     | s2   | eq_ref | PRIMARY | 4       | atguigudb1.s1.id |    1 |</span><br><span class="line">+----+------------+------+--------+---------+---------+------------------+------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>从执行计划的结果中可以看出，MySQL打算将s2作为驱动表，s1作为被驱动表，重点关注s1的访问<br>方法是 <code>eq_ref</code> ，表明在访问s1表的时候可以 <code>通过主键的等值匹配</code> 来进行访问。  </p>
</li>
<li><p><code>ref</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是`ref`</span><br><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>



<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br><span class="line">+----+-------+------+---------------+----------+---------+</span><br><span class="line">| id | table | type | possible_keys | key      | key_len |</span><br><span class="line">+----+-------+------+---------------+----------+---------+</span><br><span class="line">|  1 | s1    | ref  | idx_key1      | idx_key1 | 303     |</span><br><span class="line">+----+-------+------+---------------+----------+---------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>tips: 类型相同才可以走索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key2 = 10066;</span><br><span class="line"># 这个是不会走索引的 因为key2 是字符串</span><br><span class="line"># 类型不一样，mysql会加函数，进行隐式转换，一旦加上函数，就不会走索引了。</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><code>fulltext</code></p>
<p>全文索引</p>
</li>
<li><p><code>ref_or_null</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#当对普通二级索引进行等值匹配查询，该索引列的值也可以是`NULL`值时，那么对该表的访问方法</span><br><span class="line">#就可能是`ref_or_null`</span><br><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; OR key1 IS NULL;</span><br></pre></td></tr></table></figure>




</li>
<li><p><code>index_merge</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#单表访问方法时在某些场景下可以使用`Intersection`、`Union`、</span><br><span class="line">#`Sort-Union`这三种索引合并的方式来执行查询</span><br><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; OR key3 = &#x27;a&#x27;;</span><br><span class="line">+---+-------+------------+-------------------+--------+-------------------------------+</span><br><span class="line">| id| table | type       | key               | key_len| Extra</span><br><span class="line">+---+-------+------------+-------------------+--------+-------------------------------+</span><br><span class="line">|  1| s1    | index_merge| idx_key1,idx_key3 | 303,303| Using union(idx_key1,idx_key3)|</span><br><span class="line">+---+-------+------------+-------------------+--------+-------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从执行计划的 <code>type</code> 列的值是 <code>index_merge</code> 就可以看出，MySQL 打算使用索引合并的方式来执行<br>对 <code>s1</code> 表的查询。  </p>
</li>
<li><p><code>unique_subquery</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#`unique_subquery`是针对在一些包含`IN`子查询的查询语句中，如果查询优化器决定将`IN`子查询</span><br><span class="line">#转换为`EXISTS`子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的`type`</span><br><span class="line">#列的值就是`unique_subquery`</span><br><span class="line">EXPLAIN SELECT * FROM s1 </span><br><span class="line">WHERE key2 IN (SELECT id FROM s2 WHERE s1.key1 = s2.key1) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>




</li>
<li><p><code>index_subquery</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key3 FROM s2 where</span><br><span class="line">s1.key1 = s2.key1) OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>




</li>
<li><p><code>range</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#如果使用索引获取某些`范围区间`的记录，那么就可能使用到`range`访问方法</span><br><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 IN (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;);</span><br><span class="line"></span><br><span class="line">#同上</span><br><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;a&#x27; AND key1 &lt; &#x27;b&#x27;;</span><br></pre></td></tr></table></figure>






</li>
<li><p><code>index</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#当我们可以使用索引覆盖，但需要扫描全部的索引记录时，该表的访问方法就是`index`</span><br><span class="line">EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>索引覆盖，<code>INDEX idx_key_part(key_part1, key_part2, key_part3）</code> 这3个构成一个复合索引</p>
<p>key_part3 在复合索引里面，，查询的字段也在索引里面，干脆就直接遍历索引查出数据</p>
<p>思考： 好处，索引存的数据少，数据少页就少，这样可以减少io。</p>
</blockquote>
</li>
<li><p><code>ALL</code></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1;</span><br></pre></td></tr></table></figure>

<p>一般来说，这些访问方法中除了<code>All</code>这个访问方法外，其余的访问方法都能用到索引，除了<code>index_merge</code>访问方法外，其余的访问方法都最多只能用到一个索引。</p>
<p><strong>小结:</strong></p>
<p><strong>结果值从最好到最坏依次是：</strong></p>
<p><font color="blue">system &gt; const &gt; eq_ref &gt; ref &gt;</font></p>
<p><font color="red">fulltext &gt; ref_or_null &gt; index_merge &gt;unique_subquery &gt; index_subquery &gt; range &gt; </font></p>
<p><font color="green">index &gt; ALL </font></p>
<p><strong>SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，最好是 consts级别。（阿里巴巴<br>开发手册要求）</strong>  </p>
<h4 id="6-possible-keys和key"><a href="#6-possible-keys和key" class="headerlink" title="6. possible_keys和key"></a><strong>6. possible_keys和key</strong></h4><p>在EXPLAIN语句输出的执行计划中， <code>possible_keys</code>列表示在某个查询语句中，对某个表执行<code>单表查询时可能用</code>到的索引有哪些。一般查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用。<code>key</code>列表示<code>实际用到</code>的索引有哪些，如果为NULL，则没有使用索引。比方说下边这个查询:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key3 = &#x27;a&#x27;;</span><br><span class="line">+----+-------------+------+------+-------------------+----------+</span><br><span class="line">| id | select_type | table| type | possible_keys     | key      |</span><br><span class="line">+----+-------------+------+------+-------------------+----------+</span><br><span class="line">|  1 | SIMPLE      | s1   | ref  | idx_key1,idx_key3 | idx_key3 |</span><br><span class="line">+----+-------------+------+------+-------------------+----------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>上述执行计划的possible_keys列的值是<code>idx_key1,idx_key3</code>，表示该查询可能使用到<code>idx_key1</code> , <code>idx_key3</code>两个索引，然后key列的值是<code>idx_key3</code>，表示经过查询优化器计算使用不同索引的成本后，最后决定使用<code>idx_key3</code></p>
<blockquote>
<p>索引只能用一个。所以他要选一个出来用。查看上面 <code>index_merge  </code>  or 的话  会走索引合并。</p>
</blockquote>
<h4 id="7-key-len-☆"><a href="#7-key-len-☆" class="headerlink" title="7. key_len ☆"></a><strong>7. key_len ☆</strong></h4><ul>
<li><p>key_len：实际使用到的索引长度(即：字节数)</p>
</li>
<li><p>key_len越小 索引效果越好 这是前面学到的只是，短一点效率更高</p>
</li>
<li><p><strong>但是在联合索引里面，命中一次key_len加一次长度。越长代表精度越高，效果越好</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#7. </span><br><span class="line">EXPLAIN SELECT * FROM s1 WHERE id = 10005;</span><br><span class="line"></span><br><span class="line">## 结果key_len =4</span><br></pre></td></tr></table></figure>






<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key2 = 10126;</span><br><span class="line"></span><br><span class="line">## 结果key_len = 5</span><br></pre></td></tr></table></figure>

<p>key2 是int 类型 unique 索引。。因为还可能有一个null值，所以 null占一个字段。4+1 &#x3D; 5</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br><span class="line"></span><br><span class="line">## 结果key_len = 303 </span><br></pre></td></tr></table></figure>

<p>原因： <code>idx_key_part(key_part1, key_part2, key_part3）</code> 是3个100的字段合起来的。每一个字段可以为空，所以是101*3 &#x3D; 303</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 = &#x27;a&#x27;;</span><br><span class="line">+----+------------+------+---------------+--------------+---------+-------+------+</span><br><span class="line">| id | select_type| type | possible_keys | key          | key_len | ref   | rows |</span><br><span class="line">+----+------------+------+---------------+--------------+---------+-------+------+</span><br><span class="line">|  1 | SIMPLE     | ref  | idx_key_part  | idx_key_part | 303     | const |    1 |</span><br><span class="line">+----+------------+------+---------------+--------------+---------+-------+------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>结果key_len是303</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key_part1 = &#x27;a&#x27; AND key_part2 = &#x27;b&#x27;;</span><br><span class="line">+----+------------+-----+---------------+--------------+---------+------------</span><br><span class="line">| id | select_type|type | possible_keys | key          | key_len | ref        </span><br><span class="line">+----+------------+-----+---------------+--------------+---------+------------</span><br><span class="line">|  1 | SIMPLE     |ref  | idx_key_part  | idx_key_part | 606     | const,const</span><br><span class="line">+----+------------+-----+---------------+--------------+---------+------------</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>结果key_606</p>
<p><strong>这里命中了两次联合索引，精度更高，效果更好</strong></p>
<p><strong>练习：</strong></p>
<p><strong>key_len的长度计算公式：</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">varchar(10)变长字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)+2(变长字段)</span><br><span class="line"></span><br><span class="line">varchar(10)变长字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+2(变长字段)</span><br><span class="line"></span><br><span class="line">char(10)固定字段且允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)+1(NULL)</span><br><span class="line"></span><br><span class="line">char(10)固定字段且不允许NULL = 10 * ( character set：utf8=3,gbk=2,latin1=1)</span><br></pre></td></tr></table></figure>



<h4 id="8-ref"><a href="#8-ref" class="headerlink" title="8. ref"></a>8. ref</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 8. ref：当使用索引列等值查询时，与索引列进行等值匹配的对象信息。</span><br><span class="line">#比如只是一个常数或者是某个列。</span><br><span class="line"> </span><br><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br><span class="line">+----+-------------+------+------+---------------+----------+---------+-------+</span><br><span class="line">| id | select_type | table| type | possible_keys | key      | key_len | ref   |</span><br><span class="line">+----+-------------+------+------+---------------+----------+---------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1   | ref  | idx_key1      | idx_key1 | 303     | const |</span><br><span class="line">+----+-------------+------+------+---------------+----------+---------+-------+</span><br></pre></td></tr></table></figure>



<p>类型是type &#x3D;ref，与const（常量）比较</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;</span><br><span class="line">+---+------+--------+---------------+--------+------------------+-----</span><br><span class="line">| id| table| type   | possible_keys | key    | ref              | rows</span><br><span class="line">+---+------+--------+---------------+--------+------------------+-----</span><br><span class="line">|  1| s1   | ALL    | PRIMARY       | NULL   | NULL             | 9895</span><br><span class="line">|  1| s2   | eq_ref | PRIMARY       | PRIMARY| atguigudb1.s1.id |    1</span><br><span class="line">+---+------+--------+---------------+--------+------------------+-----</span><br></pre></td></tr></table></figure>

<p>类型是type &#x3D;eq_ref ， 与 atguigudb1.s1.id   比较</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.key1 = UPPER(s1.key1);                         </span><br><span class="line">+----+------+------+---------------+----------+---------+------+------+----------------------+</span><br><span class="line">| id | table| type | possible_keys | key      | key_len | ref  | rows |Extra                 |</span><br><span class="line">+----+------+------+---------------+----------+---------+------+------+----------------------+</span><br><span class="line">|  1 | s1   | ALL  | NULL          | NULL     | NULL    | NULL | 9895 |NULL                  |</span><br><span class="line">|  1 | s2   | ref  | idx_key1      | idx_key1 | 303     | func |    1 |Using index condition |</span><br><span class="line">+----+------+------+---------------+----------+---------+------+------+----------------------+</span><br></pre></td></tr></table></figure>

<p>与一个方法比较<code>func</code></p>
<h4 id="9-rows-☆"><a href="#9-rows-☆" class="headerlink" title="9. rows ☆"></a>9. rows ☆</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 9. rows：预估的需要读取的记录条数</span><br><span class="line"># `值越小越好`</span><br><span class="line"># 通常与filtered 一起使用</span><br><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27;;</span><br></pre></td></tr></table></figure>



<p>rows 值越小，代表，数据越有可能在一个页里面，这样io就会更小。</p>
<h4 id="10-filtered"><a href="#10-filtered" class="headerlink" title="10. filtered"></a>10. filtered</h4><p><strong>越大越好</strong></p>
<p>filtered 的值指返回结果的行占需要读到的行(rows 列的值)的百分比。</p>
<blockquote>
<p>自己的理解： 比如读了100 rows. filtered  是10% 那么就说明还要对着100条进行过滤。。。。。。。。。这个是自己意淫的完全没有根据，只能先这么理解了。</p>
</blockquote>
<p> 如果使用的是索引执行的单表扫描，那么计算时需要估计出满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326170537304.png" alt="image-20220326170537304"></p>
<p><strong>对于单表查询来说，这个filtered列的值没什么意义</strong>，我们<code>更关注在连接查询中驱动表对应的执行计划记录的filtered值</code>，它决定了被驱动表要执行的次数(即：rows * filtered)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 = s2.key1 WHERE s1.common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326171219278.png" alt="image-20220326171219278"></p>
<h4 id="11-Extra-☆"><a href="#11-Extra-☆" class="headerlink" title="11. Extra ☆"></a>11. Extra ☆</h4><p>顾名思义，<code>Extra</code>列是用来说明一些额外信息的，包含不适合在其他列中显示但十分重要的额外信息。我们可以通过这些额外信息来<code>更准确的理解MySQL到底将如何执行给定的查询语句</code>。MySQL提供的额外信息有好几十个，一下捡重点介绍</p>
<ul>
<li><p><code>No tables used</code> </p>
<p>当查询语句的没有FROM子句时将会提示该额外信息，比如:</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT 1;				</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326172022150.png" alt="image-20220326172022150"></p>
<ul>
<li><code>Impossible WHERE</code></li>
</ul>
<p> 查询语句的<code>WHERE</code>子句永远为<code>FALSE</code>时将会提示该额外信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE 1 != 1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326172126970.png" alt="image-20220326172126970"></p>
<ul>
<li><p>Using where</p>
<p>当我们使用全表扫描来执行对某个表的查询，并且该语句的<code>WHERE</code>子句中有针对该表的搜索条件时，在<code>Extra</code>列中会提示上述额外信息。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE common_field = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326172256011.png" alt="image-20220326172256011"></p>
<p>当条件除了索引，还有其他条件，也会是这个提示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#当使用索引访问来执行对某个表的查询，并且该语句的`WHERE`子句中</span><br><span class="line">#有除了该索引包含的列之外的其他搜索条件时，在`Extra`列中也会提示上述额外信息。</span><br><span class="line">explain SELECT * FROM s1 WHERE key1 = &#x27;fUhcQU&#x27; and  common_field = &#x27;uDHCOnalcF&#x27;;</span><br></pre></td></tr></table></figure>



<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326172802426.png" alt="image-20220326172802426"></p>
<ul>
<li><code>No matching min/max row</code></li>
</ul>
<p> 当查询列表处有<code>MIN</code>或者<code>MAX</code>聚合函数，但是并没有符合<code>WHERE</code>子句中的搜索条件的记录时，将会提示该额外信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 数据库不存在 QLjKYOx</span><br><span class="line">EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = &#x27;QLjKYOx&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326173156258.png" alt="image-20220326173156258"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 数据库存在 QLjKYO</span><br><span class="line">EXPLAIN SELECT MIN(key1) FROM s1 WHERE key1 = &#x27;QLjKYO&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326173338273.png" alt="image-20220326173338273"></p>
<ul>
<li><code>Using index</code></li>
</ul>
<p> 当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用覆盖索引的情况下，在<code>Extra</code>列将会提示该额外信息。</p>
<p>比方说下边这个查询中只需要用到<code>idx_key1</code>而不需要回表操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT key1 FROM s1 WHERE key1 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326173520015.png" alt="image-20220326173520015"></p>
<ul>
<li><p><code>Using index condition</code></p>
<p>有些搜索条件中虽然出现了索引列，但却不能使用到索引看课件理解索引条件下推</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key1 LIKE &#x27;%a&#x27;;</span><br><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#x27;z&#x27; AND key1 LIKE &#x27;%a&#x27;;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326173622086.png" alt="image-20220326173622086"></p>
<blockquote>
<p>步骤1. 这里key1 &gt; ‘z’ 走了索引，查出了378条数据。。。</p>
<p>步骤2.  key1 LIKE ‘%b’; 这个条件依然是 key1 索引，，，所以接下来只要在遍历这378个索引。哪些符合 ‘%a’</p>
<p>步骤3.  通过步骤2  过滤出了有效 索引。。 这就是Using index condition 。</p>
<p>步骤4. 把符合条件的索引，进行回表查询。</p>
</blockquote>
<p>完整的说明：</p>
<p>其中的<code>key1 &gt; &#39;z&#39;</code>可以使用到索引，但是<code>key1 LIKE &#39;%a &#39;</code>却无法使用到索引，在以前版本的MySQL中，是按照下边步骤来执行这个查询的:</p>
<ul>
<li>先根据key1 &gt; ‘z’这个条件，从二级索引<code>idx_key1</code>中获取到对应的二级索引记录。</li>
<li>根据上一步骤得到的二级索引记录中的主键值进行回表，找到完整的用户记录再检测该记录是否符合<code>key1 LIKE &#39;%a&#39;</code>这个条件，将符合条件的记录加入到最后的结果集。</li>
</ul>
<p>但是虽然<code>key1 LIKE ‘%a&#39;</code>不能组成范围区间参与<code>range</code>访问方法的执行，但这个条件毕竟只涉及到了<code>key1</code>列，所以MySQL把上边的步骤改进了一下:</p>
<ul>
<li><p>先根据<code>key1 &gt; &#39;z&#39;</code>这个条件，定位到二级索引<code>idx_key1</code>中对应的二级索引记录。</p>
</li>
<li><p>对于指定的二级索引记录，先不着急回表，而是先检测一下该记录是否满足<code>key1 LIKE ‘%a&#39;</code>这个条件，如果这个条件不满足，则该二级索引记录压根儿就没必要回表。</p>
</li>
<li><p>对于满足<code>key1 LIKE &#39;%a&#39;</code>这个条件的二级索引记录执行回表操作。</p>
</li>
</ul>
<p>我们说回表操作其实是一个随机IO，比较耗时，所以上述修改虽然只改进了一点点，但是可以省去好多回表操作的成本。MySQL把他们的这个改进称之为<code>索引条件下推</code> (英文名: Index Condition Pushdown )。如果在查询语句的执行过程中将要使用<code>索引条件下推</code>这个特性，在Extra列中将会显示<code>Using index condition</code></p>
</li>
<li><p><code>Using join buffer (Block Nested Loop)</code>  </p>
<p>没有索引的字段进行表关联。</p>
<p> 在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为其分配一块名叫<code>join buffer</code>的内存块来加快查询速度，也就是我们所讲的<code>基于块的嵌套循环算法</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field = s2.common_field;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326173721122.png" alt="image-20220326173721122"></p>
</li>
<li><p><code>Not exists</code></p>
<p>当我们使用左（外）连接时，如果<code>WHERE</code>子句中包含要求被驱动表的某个列等于<code>NULL</code>值的搜索条件，而且那个列又是不允许存储<code>NULL</code>值的，那么在该表的执行计划的Extra列就会提示<code>Not exists</code>额外信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 = s2.key1 WHERE s2.id IS NULL;</span><br><span class="line"># 都表关联了，，关联字段怎么会等于 is null</span><br></pre></td></tr></table></figure>



<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326182016458.png" alt="image-20220326182016458"></p>
</li>
<li><p><code>Using intersect(...) 、 Using union(...) 和 Using sort_union(...)</code>  </p>
<ul>
<li><p>如果执行计划的<code>Extra</code>列出现了<code>Using intersect(...)</code>提示，说明准备使用<code>Intersect</code>索引</p>
</li>
<li><p>合并的方式执行查询，括号中的<code>...</code>表示需要进行索引合并的索引名称；</p>
</li>
<li><p>如果出现了<code>Using union(...)</code>提示，说明准备使用<code>Union</code>索引合并的方式执行查询；</p>
</li>
<li><p>出现了<code>Using sort_union(...)</code>提示，说明准备使用<code>Sort-Union</code>索引合并的方式执行查询。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 WHERE key1 = &#x27;a&#x27; OR key3 = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326182155207.png" alt="image-20220326182155207"></p>
</li>
<li><p><code>Zero limit</code></p>
</li>
<li><p><code>Using filesort</code></p>
<p>有一些情况下对结果集中的记录进行排序是可以使用到索引的，比如下边这个查询:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 ORDER BY key1 LIMIT 10;</span><br></pre></td></tr></table></figure>

<p>这个查询语句可以利用<code>idx_key1</code>索引直接取出key1列的10条记录，然后再进行回表操作就好了。但是很多情况下排序操作无法使用到索引，只能在内存中(记录较少的时候）或者磁盘中(记录较多的时候）进行排序，MySQL把这种在内存中或者磁盘上进行排序的方式统称为文件排序（英文名: <code>filesort</code>)。如果某个查询需要使用文件排序的方式执行查询，就会在执行计划的Extra列中显示<code>Using filesort</code>提示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM s1 ORDER BY common_field LIMIT 10;</span><br></pre></td></tr></table></figure>


</li>
<li><p><code>Using temporary</code>  </p>
<p>在许多查询的执行过程中，MySQL可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含<code>DISTINCT</code>、<code>GROUP BY</code>、<code>UNION</code>等子句的查询过程中，如果不能有效利用索引来完成查询，MySQL很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的<code>Extra</code>列将会显示<code>Using temporary</code>提示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT DISTINCT common_field FROM s1;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326183048710.png" alt="image-20220326183048710"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#执行计划中出现`Using temporary`并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以</span><br><span class="line">#我们`最好能使用索引来替代掉使用临时表`。比如：扫描指定的索引idx_key1即可</span><br><span class="line">EXPLAIN SELECT key1, COUNT(*) AS amount FROM s1 GROUP BY key1;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20220326183135116.png" alt="image-20220326183135116"></p>
</li>
</ul>
<h4 id="12-小结"><a href="#12-小结" class="headerlink" title="12. 小结"></a>12. 小结</h4><ul>
<li>EXPLAIN不考虑各种Cache</li>
<li>EXPLAIN不能显示MySQL在执行查询时所作的优化工作</li>
<li>EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况</li>
<li>部分统计信息是估算的，并非精确值</li>
</ul>
<h2 id="六、事务日志"><a href="#六、事务日志" class="headerlink" title="六、事务日志"></a>六、事务日志</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><ul>
<li><p>事务有4种特性：原子性、一致性、隔离性和持久性。</p>
</li>
<li><p>事务的隔离性由锁机制实现，而事务的 原子性、一致性和持久性 由事务的 <code>redo日志</code> 和 <code>undo日志</code> 来保证。</p>
</li>
<li><p>REDO LOG ： 重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</p>
</li>
<li><p>UNDO LOG ： 回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。</p>
</li>
<li><p>REDO 和 UNDO 都可以视为是一种恢复操作，区别如下：</p>
</li>
<li><p>redo log：是存储引擎层（innodb）生成的日志，记录的是物理级别上的页修改操作，比如某页号、某偏移量写入了什么数据，主要为了保证数据的可靠性</p>
</li>
<li><p>undo log：也是存储引擎层（innodb）生成的日志，记录的是逻辑操作日志，比如对某一行数据进行了INSERT语句操作，那么 undo log 就记录一条与之相反的 DELETE 操作。主要用于事务的 回滚（undo log记录的是每个修改操作的逆操作）和 一致性非锁定读。</p>
</li>
</ul>
<h3 id="6-2-redolog"><a href="#6-2-redolog" class="headerlink" title="6.2 redolog"></a>6.2 redolog</h3><blockquote>
<p>为什么需要redolog</p>
</blockquote>
<ul>
<li><p>InnoDB存储引擎是<code>以页为单位</code>来管理存储空间的。在真正访问页面之前，需要把在磁盘上的页<code>缓存到内存中的 Buffer Pool</code>之后才可以访问。</p>
</li>
<li><p>所有的变更都必须先更新缓冲池中的数据，然后缓冲池中的脏页会以<strong>一定的频率被刷入磁盘</strong>（checkPoint机制），通过缓冲池来优化CPU和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太快。</p>
</li>
<li><p>但是，因为checkPoint不是每次变更就触发，如果在commit之后刚写完缓冲池数据库宕机了，那么这部分数据就丢失了。</p>
</li>
<li><p>这样就不能保证持久性，想要尽可能保证持久性，我们可以简单粗暴的，当内存中的数据修改了，我们就马上去更新磁盘，但是这样存在两个问题：</p>
<ul>
<li>1.InnoDB以页为单位进行磁盘IO，这就造成，当我们仅仅修改一个字节时，也不得不将一个完整的页刷新到磁盘。</li>
<li>2.一条update语句可能修改很多页面，这些页面可能并不相邻，<strong>这时就需要进行很多的随机IO，随机IO刷新较慢</strong></li>
</ul>
</li>
<li><p>怎样更好的解决上边的问题呢？ 这时redo日志就来了。</p>
</li>
<li><p><strong>我们只是想要当事物提交之后，内存中的数据肯定改了，这时磁盘的数据也一定要能改。我们的思路就是不频繁刷盘，而是先将所做的修改保存到一个文件里边，这个文件起名叫做 redo日志，这样的话，就算修改内存还没来得及刷新磁盘宕机了，重启后也可以根据 redo日志 来恢复，以此来保证持久性。</strong></p>
</li>
<li><p>InnoDB引擎的事务采用了WAL技术（Write－Ahead Logging），这种技术的思想就是先写日志，再写磁盘，只有日志写入成功，才算事务提交成功，这里的日志就是redo log，当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，以保证ACID中的D。</p>
</li>
</ul>
<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230704091236416.png" alt="image-20230704091236416"></p>
<blockquote>
<p>redolog的特点</p>
</blockquote>
<ul>
<li>降低的刷盘频率</li>
<li>占用空间小，刷盘快</li>
<li>顺序写入，顺序IO比随机IO快</li>
<li>事务过程中，redo log不断记录</li>
</ul>
<blockquote>
<p>redolog和binlog的区别</p>
</blockquote>
<p>redo log是存储引擎层产生的，而bin log是数据库层产生的。</p>
<p>一个事物过程中，会一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</p>
<blockquote>
<p>redolog的整体步骤</p>
</blockquote>
<p>redo log 整体流程大致分为四步：</p>
<ul>
<li>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝；</li>
<li>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值；</li>
<li>第3步：当事务commit时，将redo log buffer中的内容刷新到redo log file，对redo log file采用追加写的方式</li>
<li>第4步：定期将内存中修改的数据刷新到磁盘中<br><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230704091632501.png" alt="image-20230704091632501"></li>
</ul>
<blockquote>
<p>redo log 的刷盘策略</p>
</blockquote>
<p>redo log 的刷盘策略，指的是将redo log buffer中的内容刷新到redo log file这一步，虽然它不是真正的将数据刷新到磁盘，但是，只要这一步不出现问题，就可以保证我们的持久化成功了</p>
<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230704091859240.png" alt="image-20230704091859240"></p>
<p>redo log 的刷盘策略由 innodb＿flush＿log＿at＿trx＿commit 这个参数控制，值可以为 0，1，2，代表三种策略，默认为 1。</p>
<p>三种策略如下：</p>
<ul>
<li>值为0：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</li>
<li>值为1：表示每次事务提交时都将进行同步刷盘操作（默认）</li>
<li>值为2：表示每次事务提交时都只把redo log buffer内容写入page cache，不进行同步。由OS自己决定什么时候同步到磁盘文件。</li>
</ul>
<h3 id="6-3-undolog"><a href="#6-3-undolog" class="headerlink" title="6.3 undolog"></a>6.3 undolog</h3><blockquote>
<p>什么是undo日志</p>
</blockquote>
<ul>
<li>其实，在事务更新数据之前，有一步写入 undo log 的操作，undo log 用来保证事务的原子性。</li>
<li>当事务执行过程中出现各种错误时，这个事务需要回滚，把数据改回原先的样子，所以就需要 undo 日志 来记录旧值。</li>
<li>此外，undo log 的产生会伴随着 redo log 的产生，因为 undo log 也需要持久性保护。</li>
</ul>
<blockquote>
<p>undolog的作用</p>
</blockquote>
<ul>
<li>回滚数据</li>
<li>MVCC（当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。）</li>
</ul>
<blockquote>
<p>undolog和undolog页</p>
</blockquote>
<ul>
<li>写 undo log 时，会申请一个undo 页，在页中进行写入；</li>
<li>但是为每一个事务分配一个页，是非常浪费内存的，所以undo页被设计为是可以重用的；</li>
<li>当事务提交时，并不会立刻删除undo页，而是判断是否可以重用；</li>
<li>undo log 在 commit 后，会被放到一个链表中，然后判断undo页的使用空间是否小于3／4，如果小于3／4的话，则表示当前的 undo页 可以被重用，那么它</li>
<li>就不会被回收，其他事务的 undo log 可以记录在当前undo页的后面。</li>
<li>由于undo log是离散的，所以清理对应的磁盘空间时，效率不高。</li>
</ul>
<blockquote>
<p>主流程</p>
</blockquote>
<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230704092747844.png" alt="image-20230704092747844"></p>
<p>undo log是逻辑日志，对事务回滚时，只是将数据库逻辑地恢复到原来的样子。</p>
<p> redo log是物理日志，记录的是数据页的物理变化，undo log不是redo log的逆过程。</p>
<h2 id="七、锁"><a href="#七、锁" class="headerlink" title="七、锁"></a>七、锁</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><ul>
<li>事务的隔离性就是由锁来实现。</li>
<li>锁是计算机协调多个进程或线程并发访问某一资源的机制。和在开发中加锁以保证数据的一致性一样，这个思想在数据库领域中同样很重要。</li>
<li>在数据库中，数据是一种供许多用户共享的资源，为保证数据的一致性，需要对并发操作进行控制，因此产生了锁。同时锁机制也为实现MySQL的各个隔离级别提供了保证。</li>
</ul>
<blockquote>
<p>MySQL并发事物访问相同记录的几种情况？</p>
</blockquote>
<p>对于两个事务，我们把<code>增删改叫做写操作，查询叫做读操作</code>，有以下几种情况：</p>
<ol>
<li>读–读情况</li>
</ol>
<ul>
<li>读操作不会对记录有任何影响，所以存在任何的问题</li>
</ul>
<ol start="2">
<li>写–写情况</li>
</ol>
<ul>
<li>这种情况就会出现脏写的情况，是不允许发生的</li>
<li>所以在多个未提交事物对同一条记录改动时，需要让他们排队执行，这就使用到了锁机制</li>
<li>在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录进行关联</li>
<li>当一个事务想对这条记录做改动时，首先会看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。</li>
</ul>
<ol start="3">
<li>读–写情况（写–读情况）</li>
</ol>
<ul>
<li>这种情况可能会出现 脏读、不可重复读和幻读</li>
<li>对于这些情况，就出现了对应的隔离级别</li>
</ul>
<ol start="4">
<li>怎么解决这些问题呢？</li>
</ol>
<p>方案一：读操作使用多版本并发控制（MVCC,后边会讲），写操作进行加锁<br>方案二：读操作和写操作都进行加锁</p>
<p>方案一性能更好，因为读写操作不冲突，而方案二读写操作需要排队执行</p>
<h3 id="7-2-从不同的角度对锁进行分类"><a href="#7-2-从不同的角度对锁进行分类" class="headerlink" title="7.2 从不同的角度对锁进行分类"></a>7.2 从不同的角度对锁进行分类</h3><blockquote>
<p>操作类型划分</p>
</blockquote>
<ul>
<li><p>读锁：也称为共享锁、英文用s表示。<br>针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞。<br>读锁可以是共享的，也可以是排他的</p>
</li>
<li><p>写锁：也称为排他锁、英文用x表示。<br>当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。</p>
</li>
</ul>
<blockquote>
<p>根据粒度划分</p>
</blockquote>
<p>为了尽可能的提高数据的并发度，每次锁定的数据范围越小越好，但是管理锁却是一件很耗资源的事情，锁粒度就是用来平衡高并发响应和系统性能的。</p>
<p>表锁:</p>
<ul>
<li>该锁会锁定整张表，什么存储引擎的表锁策略都相同</li>
<li>因为<code>表锁的粒度比较大，所以它的开销比较小，可以很好的避免死锁，但并发性较差</code></li>
</ul>
<ol>
<li>表级别的S锁、X锁</li>
</ol>
<ul>
<li><p>在对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，InnoDB存储引擎是不会为这个表添加表级别的S锁或者X锁的。</p>
</li>
<li><p>而在对某个表执行一些诸如ALTER TABLE、DROP TABLE这类的DDL语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。</p>
</li>
<li><p>同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行DDL语句也会发生阻塞。</p>
</li>
<li><p><strong>这个过程其实是通过在server层使用一种称之为元数据锁结构来实现的。</strong></p>
</li>
<li><p>一般情况下，不会使用InnoDB存储引擎提供的表级别的S锁和X锁。只会在一些特殊情况下，比方说崩溃恢复过程中用到。</p>
</li>
<li><p><strong>应尽量避免在使用InnoDB存储引擎的表上使用LOCK TABLES这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。InnoDB的特殊之处还是实现了更细粒度的行锁。</strong></p>
</li>
</ul>
<ol start="2">
<li>表的意向锁</li>
</ol>
<ul>
<li><p>lnnoDB支持多粒度锁，它允许行级锁与表级锁共存，而意向锁就是其中的一种表锁。</p>
<ul>
<li>意向锁的存在是为了<code>协调行锁和表锁的关系</code>，支持多粒度（表锁与行锁）的锁并存。</li>
<li>意向锁是一种<code>不与行级锁冲突表级锁</code>，这一点非常重要。</li>
<li>表明“某个事务正在某些行持有了锁或该事务准备去持有锁”</li>
</ul>
</li>
<li><p>意向锁分为两种：</p>
<ul>
<li>意向共享锁：事务有意向对表中的某些行加共享锁（S锁）</li>
<li>意向排他锁：事务有意向对表中的某些行加排他锁（X锁）</li>
</ul>
</li>
</ul>
<p><strong>意向锁在保证并发性的前提下，实现了行锁和表锁共存且满足事务隔离性的要求。</strong></p>
<p>意向锁是由存储引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享／排他锁之前，InooDB会先获取该数据行所在数据表的对应意向锁。</p>
<ol start="3">
<li>自增锁</li>
</ol>
<ul>
<li>自增锁是<strong>当向使用含有AUTO＿INCREMENT列的表中插入数据时需要获取的一种特殊的表级锁</strong>，在执行插入语句时就在表级别加一个自增锁，然后为每条待插入记录的AUTO＿INCREMENT修饰的列分配递增的值，在该语句执行结束后，再把锁释放掉。</li>
<li>一个事务在持有自增锁的过程中，<strong>其他事务的插入语句都要被阻塞</strong>，可以保证一个语句中分配的递增值是连续的。</li>
<li>所以，其并发性并不高，当我们向一个有AUTO＿INCREMENT关键字的主键插入值的时候，每条语句都要对这个表锁进行竞争，所以InnoDB通过&#x3D;&#x3D;innodb＿autoinc＿lock＿mode（0，1，2）&#x3D;&#x3D;的不同取值来提供不同的锁定机制，来提高SQL语句的可伸缩性和性能。</li>
</ul>
<ol start="4">
<li>元数据锁（MDL锁）</li>
</ol>
<ul>
<li>元数据锁的作用是保证读写的正确性。</li>
<li>比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，增加了一列，那么查询线程拿到的结果跟表结构对不上，这肯定是不行的。</li>
<li>因此，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。</li>
<li>读锁之间不互斥，因此可以有多个线程同时对一张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。</li>
<li>它不需要显式使用，在访问一个表的时候会被自动加上。</li>
</ul>
<p>行锁:</p>
<ul>
<li>优点：锁定力度小，发生锁冲突概率低，可以实现的并发度高。</li>
<li>缺点：对于锁的开销比较大，加锁会比较慢，容易出现死锁情况。</li>
<li>InnoDB与MylSAM的最大不同有两点：一是支持事务；二是采用了行级锁。</li>
</ul>
<ol>
<li>记录锁</li>
</ol>
<ul>
<li>记录锁就是仅仅把一条记录锁上，对周围的数据没有影响。</li>
<li>记录锁分为S型记录锁和X型记录锁。<ul>
<li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li>
<li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>间隙锁</li>
</ol>
<ul>
<li>幻读的解决方案有两种，第一可以使用MVCC方案解决，第二也可以采用加锁方案解决。</li>
<li>但是在使用加锁方案解决时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上记录锁。</li>
<li>InnoDB提出了一种称之为Gap Locks的锁（间隙锁），不允许别的事务在间隙锁记录前边的间隙插入新记录。</li>
<li>gap锁的提出仅仅是为了防止插入幻影记录而提出的。虽然有共享gap锁和独占gap锁，但是它们起到的作用是相同的。如果对一条记录加了gap锁（不论是共享还是独占），并不会限制其他事务对这条记录加记录锁或者继续加gap锁。</li>
</ul>
<ol start="3">
<li>临键锁</li>
</ol>
<ul>
<li>有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录，所以InnoDB就提出了一种临建锁。</li>
<li>临键锁是在存储引擎Innodb、事务级别在可重复读的情况下使用的数据库锁，Innodb默认的锁就是临键锁。</li>
<li>他就相当于记录锁和间隙锁的合体。</li>
</ul>
<ol start="4">
<li>插入意向锁</li>
</ol>
<ul>
<li>一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了gap锁，如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交。</li>
<li>但是lnnoDB规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新录，但是现在在等待。InnoDB就把这种类型的锁命名为插入意向锁。</li>
<li>插入意向锁是一种Gap锁，不是意向锁，在insert操作时产生。</li>
<li>插入意向锁是在插入一条记录行前，由INSERT操作产生的一种间隙锁。该锁用以表示插入意向，当多个事务在同一区间插入位置不同的多条数据时，事务之间不需要互相等待。</li>
<li><strong>插入意向锁的特性：</strong><ul>
<li>插入意向锁是一种特殊的间隙锁，间隙锁可以锁定开区间内的部分记录。</li>
<li>插入意向锁之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身不冲突，那么事务之间就不会出现冲突等待。</li>
</ul>
</li>
</ul>
<p>虽然插入意向锁中含有意向锁三个字，但是它并不属于意向锁而属于间隙锁，因为意向锁是表锁，而插入意向锁是行锁。</p>
<p>页锁:</p>
<ul>
<li>页锁就是在页的粒度上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。</li>
<li>页锁的开销介于表锁和行锁之间，会出现死锁，锁定粒度介于表锁和行锁之间。</li>
</ul>
<h2 id="八、MVCC多版本并发控制原理剖析"><a href="#八、MVCC多版本并发控制原理剖析" class="headerlink" title="八、MVCC多版本并发控制原理剖析"></a>八、MVCC多版本并发控制原理剖析</h2><h3 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h3><ul>
<li>MVCC（Multiversion Concurrency Control）多版本并发控制。</li>
<li><strong>就是通过数据行的多个版本管理来实现数据库的并发控制。</strong></li>
<li>这项技术使得在InnoDB的事务隔离级别下执行一致性读操作有了保证。</li>
<li>换句话说，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁。</li>
</ul>
<h3 id="8-2-快照读与当前读"><a href="#8-2-快照读与当前读" class="headerlink" title="8.2 快照读与当前读"></a>8.2 快照读与当前读</h3><ol>
<li>快照读</li>
</ol>
<ul>
<li>快照读又叫一致性读，读取的是快照数据。</li>
<li>不加锁的简单的SELECT都属于快照读，即不加锁的非阻塞读</li>
<li>之所以出现快照读，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销。</li>
<li>既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。</li>
<li>快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读</li>
</ul>
<ol start="2">
<li>当前读</li>
</ol>
<ul>
<li>当前读读取的是记录的最新版本，最新数据，读取时还要保证其他并发事务不能修改。</li>
<li>当前记录会对读取的记录进行加锁。加锁的SELECT，或者对数据进行增删改都会进行当前读。</li>
</ul>
<p>在以前学习隔离级别时，对于SQL标准中，可重复读 解决了脏读，不可重复读的问题，没有解决幻读。但是在MySQL中，因为MVCC，读的时候其实读的是快照，所以也不会出现幻读。</p>
<h3 id="8-3-MVCC实现原理"><a href="#8-3-MVCC实现原理" class="headerlink" title="8.3 MVCC实现原理"></a>8.3 MVCC实现原理</h3><p><strong>MVCC 的实现依赖于：隐藏字段，Undo Log、Read View</strong></p>
<ol>
<li>隐藏字段</li>
</ol>
<ul>
<li>对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列。<ul>
<li>trx＿id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx＿id隐藏列。</li>
<li>roll＿pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。（每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll＿pointer属性，可以将这些undo日志都连起来，串成一个链表，就是版本链）</li>
</ul>
</li>
</ul>
<p><img src="/2023/07/02/Mysql%E9%AB%98%E7%BA%A7/image-20230704100613460.png" alt="image-20230704100613460"></p>
<p><code>insert undo 只在事物回滚时起作用，当事物提交后，该类型的undo日志就没有用了，就会被系统回收。</code></p>
<ol start="2">
<li>Read View</li>
</ol>
<p>在MVCC机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在Undo Log里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录，就需要用到ReadView了，它帮我们解决了行的可见性问题。</p>
<p><strong>ReadView就是一个事务在使用MVCC机制进行快照读操作时产生的读视图。</strong>当事务启动时，会生成数据库系统当前的一个快照，InnoDB为每个事务构造了一个数组，用来记录并维护系统当前<code>活跃事务的ID</code>（“活跃”指的就是，启动了但还没提交）。</p>
<ol start="3">
<li>思路设计</li>
</ol>
<p>使用 READ UNCOMMITTED 隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</p>
<p>使用 SERIALIZABLE 隔离级别的事务，InnoDB规定使用加锁的方式来访问记录。</p>
<p>所以，以上两个隔离级别READ UNCOMMITTED、SERIALIZABLE是用不着MVCC的。</p>
<p><strong>使用 READ COMMITTED 和 REPEATABLE READ 隔离级别的事务，都必须保证读到已经提交了的事务修改过的记录，他俩就用到了MVCC机制。</strong></p>
<p>假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p>
<ul>
<li>ReadView中主要的参数：<ul>
<li>creator_trx_id：创建这个ReadView的事物ID</li>
<li>trx_ids：创建ReadView时当前系统的活跃的读写事物列表</li>
<li>up_limit_id：活跃事物中最小的ID</li>
<li>low_limit_id：已提交事物最大的事物ID（1，2，3事物，1、2未提交3已提交，最大事物ID为3+1&#x3D;4）</li>
</ul>
</li>
</ul>
<ol start="4">
<li>ReadView使用规则</li>
</ol>
<ul>
<li>如果被访问版本的trx＿id属性值与ReadView中的creator＿trx＿id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx＿id属性值小于ReadView中的up＿limit＿id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx＿id属性值大于或等于ReadView中的low＿limit＿id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。<ul>
<li>如果被访问版本的trx＿id属性值在ReadView的up＿limit＿id和low＿limit＿id之间，那就需要判断一下trx＿id 属性值是不是在trx＿ids列表中。</li>
<li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li>
<li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
</li>
</ul>
<ol start="5">
<li>MVCC整体操作流程<br>比如现在执行一条查询语句：</li>
</ol>
<ul>
<li><p>1.首先获取事务自己的版本号，也就是事务ID；</p>
</li>
<li><p>2.获取ReadView；</p>
</li>
<li><p>3.查询得到的数据，然后与ReadView中的事务版本号进行比较；</p>
</li>
<li><p>4.如果不符合ReadView规则，就需要从Undo Log中获取历史快照（顺着版本链向下找，如果直到最后一个版本还不可见的话，就意味着这条记录对该事物完全不可见，查询结果就不包含该记录）；</p>
</li>
<li><p>5.最后返回符合规则的数据。</p>
<p>隔离级别为读已提交时，一个事物每次select都会重新获取一次ReadView<br>隔离级别为可重复读时，一个事物只在第一次select时获取一次ReadView</p>
</li>
</ul>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left  disabled "
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/2022/06/16/MySQL45%E8%AE%B2/"
      title="MySql45讲"
     >

    <p class="title-text">
      
        MySql45讲
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>

 
    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2023 高喆<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn" onclick="topFunction()">
        <span class="material-symbols-rounded">keyboard_arrow_up</span>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.style.opacity = 1;
        } else {
            btn.style.opacity = 0;
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
