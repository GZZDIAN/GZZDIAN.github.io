

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="gaozhe">
  <meta name="keywords" content="">
  
    <meta name="description" content="面试常见题Java基础篇1. 说下反射 是什么?  简单来说就是可以在运行时获取类的属性和方法, 还可以调用其方法  获取Class的四种方式  1. 知道具体类的情况下可以使用： 1Class alunbarClass &#x3D; TargetObject.class;  但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化 2">
<meta property="og:type" content="article">
<meta property="og:title" content="面试常见题">
<meta property="og:url" content="http://example.com/2022/05/01/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BD%92%E7%BA%B3/index.html">
<meta property="og:site_name" content="gzzear&#39;s blog">
<meta property="og:description" content="面试常见题Java基础篇1. 说下反射 是什么?  简单来说就是可以在运行时获取类的属性和方法, 还可以调用其方法  获取Class的四种方式  1. 知道具体类的情况下可以使用： 1Class alunbarClass &#x3D; TargetObject.class;  但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化 2">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/05/01/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BD%92%E7%BA%B3/image-20220517180949130.png">
<meta property="og:image" content="http://example.com/2022/05/01/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BD%92%E7%BA%B3/image-20220517181700085.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/3003862/1649232795540-336b7a30-7fa2-4983-8b6a-7b77646bdb39.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/3003862/1649232917219-784c7da0-9aea-4381-a80e-0d6a01e00193.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/3003862/1649234464843-784b3861-5e46-415a-9177-9ad6119c9a01.png">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/3003862/1649234676561-8b951125-b650-4cf4-8895-ea8ef62028e5.png">
<meta property="og:image" content="http://example.com/2022/05/01/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BD%92%E7%BA%B3/image-20220524223851156.png">
<meta property="og:image" content="http://example.com/2022/05/01/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BD%92%E7%BA%B3/image-20220524223912311.png">
<meta property="og:image" content="http://example.com/2022/05/01/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BD%92%E7%BA%B3/image-20220524230508039.png">
<meta property="article:published_time" content="2022-05-01T15:25:08.000Z">
<meta property="article:modified_time" content="2023-08-16T07:16:50.341Z">
<meta property="article:author" content="gaozhe">
<meta property="article:tag" content="面试总结">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2022/05/01/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BD%92%E7%BA%B3/image-20220517180949130.png">
  
  
  
  <title>面试常见题 - gzzear&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面试常见题"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-05-01 23:25" pubdate>
          2022年5月1日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          39k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          323 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">面试常见题</h1>
            
            
              <div class="markdown-body">
                
                <h1 id><a href="#" class="headerlink" title></a></h1><h1 id="面试常见题"><a href="#面试常见题" class="headerlink" title="面试常见题"></a>面试常见题</h1><h2 id="Java基础篇"><a href="#Java基础篇" class="headerlink" title="Java基础篇"></a>Java基础篇</h2><h3 id="1-说下反射"><a href="#1-说下反射" class="headerlink" title="1. 说下反射"></a>1. 说下反射</h3><blockquote>
<p>是什么?</p>
</blockquote>
<p>简单来说就是可以在运行时获取类的属性和方法, 还可以调用其方法</p>
<blockquote>
<p>获取Class的四种方式</p>
</blockquote>
<p><strong>1. 知道具体类的情况下可以使用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass</span> <span class="hljs-operator">=</span> TargetObject.class;<br></code></pre></td></tr></table></figure>

<p>但是我们一般是不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化</p>
<p><strong>2. 通过 <code>Class.forName()</code>传入类的全路径获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass1</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;cn.javaguide.TargetObject&quot;</span>);<br></code></pre></td></tr></table></figure>

<p><strong>3. 通过对象实例<code>instance.getClass()</code>获取：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TargetObject</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TargetObject</span>();<br><span class="hljs-type">Class</span> <span class="hljs-variable">alunbarClass2</span> <span class="hljs-operator">=</span> o.getClass();<br></code></pre></td></tr></table></figure>

<p><strong>4. 通过类加载器<code>xxxClassLoader.loadClass()</code>传入类路径获取:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassLoader.getSystemClassLoader().loadClass(<span class="hljs-string">&quot;cn.javaguide.TargetObject&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行</p>
<h3 id="2-自动装箱、拆箱的原理是什么？"><a href="#2-自动装箱、拆箱的原理是什么？" class="headerlink" title="2. 自动装箱、拆箱的原理是什么？"></a>2. 自动装箱、拆箱的原理是什么？</h3><ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment">//拆箱</span><br></code></pre></td></tr></table></figure>

<p>从字节码中，我们发现装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</p>
<p>因此，</p>
<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li>
</ul>
<h3 id="3-深拷贝与浅拷贝的区别？"><a href="#3-深拷贝与浅拷贝的区别？" class="headerlink" title="3. 深拷贝与浅拷贝的区别？"></a>3. 深拷贝与浅拷贝的区别？</h3><ul>
<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>
<li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li>
</ul>
<h3 id="5-说下java中的异常体系？"><a href="#5-说下java中的异常体系？" class="headerlink" title="5. 说下java中的异常体系？"></a>5. 说下java中的异常体系？</h3><p><strong>Java 异常类层次结构图概览</strong> ：</p>
<p><img src="/2022/05/01/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BD%92%E7%BA%B3/image-20220517180949130.png" srcset="/img/loading.gif" lazyload alt="image-20220517180949130"></p>
<p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p>
<ul>
<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li>
<li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止</li>
</ul>
<h3 id="6-finally结构中的一定会执行吗？"><a href="#6-finally结构中的一定会执行吗？" class="headerlink" title="6. finally结构中的一定会执行吗？"></a>6. finally结构中的一定会执行吗？</h3><p>不一定的！在某些情况下，finally 中的代码不会被执行。</p>
<p>就比如说 finally 之前虚拟机被终止运行（虚拟机出现错误）的话，finally 中的代码就不会被执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Try to do something&quot;</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;RuntimeException&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());<br>    <span class="hljs-comment">// 终止当前正在运行的Java虚拟机</span><br>    System.exit(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Finally&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="7-什么是序列化、什么是反序列化？"><a href="#7-什么是序列化、什么是反序列化？" class="headerlink" title="7. 什么是序列化、什么是反序列化？"></a>7. 什么是序列化、什么是反序列化？</h3><ul>
<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<h3 id="8-java中IO流类型？"><a href="#8-java中IO流类型？" class="headerlink" title="8. java中IO流类型？"></a>8. java中IO流类型？</h3><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
</ul>
<h3 id="9-说说java中的代理模式"><a href="#9-说说java中的代理模式" class="headerlink" title="9. 说说java中的代理模式"></a>9. 说说java中的代理模式</h3><blockquote>
<p>静态代理</p>
</blockquote>
<p>静态代理中，每次对目标方法的加强都需要手动地去实现，非常麻烦，每次都得去实现一个代理类。</p>
<p>举例：</p>
<p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SmsService</span> &#123;<br>    String <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SmsService</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;send message:&quot;</span> + message);<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>3.创建代理类并同样实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SmsService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SmsService smsService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SmsProxy</span><span class="hljs-params">(SmsService smsService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.smsService = smsService;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-comment">//调用方法之前，我们可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;before method send()&quot;</span>);<br>        smsService.send(message);<br>        <span class="hljs-comment">//调用方法之后，我们同样可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;after method send()&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<blockquote>
<p>动态代理</p>
</blockquote>
<p>动态代理分为两种：<strong>JDK动态代理机制</strong>、<strong>CGLIB动态代理机制</strong></p>
<p>下面就分别说说：</p>
<p><strong>在JDK  动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>
<p>举例：</p>
<p><strong>1.定义发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SmsService</span> &#123;<br>    String <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>2.实现发送短信的接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SmsService</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;send message:&quot;</span> + message);<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>3.定义一个 JDK 动态代理类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代理类中的真实对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DebugInvocationHandler</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;<br>        <span class="hljs-comment">//调用方法之前，我们可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;before method &quot;</span> + method.getName());<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>        <span class="hljs-comment">//调用方法之后，我们同样可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;after method &quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><span style="color:red;"><strong>但是JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></span></p>
<p>但是使用CGLIB可以解决。</p>
<p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong></p>
<p>举例：</p>
<p>不同于 JDK 动态代理不需要额外的依赖。<a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">CGLIBopen in new window</a>(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p><strong>1.实现一个使用阿里云发送短信的类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliSmsService</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;send message:&quot;</span> + message);<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>2.自定义 <code>MethodInterceptor</code>（方法拦截器）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义MethodInterceptor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o           代理对象（增强的对象）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method      被拦截的方法（需要增强的方法）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args        方法入参</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> methodProxy 用于调用原始方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">//调用方法之前，我们可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;before method &quot;</span> + method.getName());<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> methodProxy.invokeSuper(o, args);<br>        <span class="hljs-comment">//调用方法之后，我们同样可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;after method &quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>3.获取代理类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxyFactory</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> &#123;<br>        <span class="hljs-comment">// 创建动态代理增强类</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        <span class="hljs-comment">// 设置类加载器</span><br>        enhancer.setClassLoader(clazz.getClassLoader());<br>        <span class="hljs-comment">// 设置被代理类</span><br>        enhancer.setSuperclass(clazz);<br>        <span class="hljs-comment">// 设置方法拦截器</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DebugMethodInterceptor</span>());<br>        <span class="hljs-comment">// 创建代理类</span><br>        <span class="hljs-keyword">return</span> enhancer.create();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="10-JDK动态代理和CGLIB动态代理的区别？"><a href="#10-JDK动态代理和CGLIB动态代理的区别？" class="headerlink" title="10. JDK动态代理和CGLIB动态代理的区别？"></a>10. JDK动态代理和CGLIB动态代理的区别？</h3><ol>
<li><span style="color:red;"><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong></span>  另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li>
<li>JDK动态代理的效率会更高</li>
</ol>
<h3 id="11-讲讲java中的引用类型？"><a href="#11-讲讲java中的引用类型？" class="headerlink" title="11. 讲讲java中的引用类型？"></a>11. 讲讲java中的引用类型？</h3><p>引用类型分为：软引用、弱引用、强引用、虚引用。</p>
<ul>
<li>弱引用：无论是否空闲，jvm都会回收。</li>
<li>软引用：jvm会判断内存是否空闲，如果不是空闲的话，就会回收软引用指向的对象。</li>
<li>强引用：由于强引用的存在，JVM很难回收，容易导致内存泄漏。</li>
<li>虚引用：加不加引用都差不多，jvm随时可能会回收</li>
</ul>
<h3 id="12-说说内存溢出和内存泄露的区别？"><a href="#12-说说内存溢出和内存泄露的区别？" class="headerlink" title="12. 说说内存溢出和内存泄露的区别？"></a>12. 说说内存溢出和内存泄露的区别？</h3><p>内存溢出：内存已经不足了，经过垃圾回收之后还是不足。</p>
<p>内存泄漏：由于不当的操作，导致创建出的对象的生命周期过长甚至导致了OOM，无法回收了。内存泄漏会导致内存溢出。</p>
<h3 id="13-Files常用的方法"><a href="#13-Files常用的方法" class="headerlink" title="13. Files常用的方法"></a>13. Files常用的方法</h3><ul>
<li>Files.exists()：检测文件路径是否存在。</li>
<li>Files.createFile()：创建文件。</li>
<li>Files.createDirectory()：创建文件夹。</li>
<li>Files.delete()：删除一个文件或者目录。</li>
<li>Files.copy()：复制文件。</li>
<li>Files.size()：移动文件</li>
<li>Files.read()：读取文件</li>
<li>Files.write()：写入文件</li>
</ul>
<h3 id="14-final、finally、finalize有什么区别？"><a href="#14-final、finally、finalize有什么区别？" class="headerlink" title="14. final、finally、finalize有什么区别？"></a>14. final、finally、finalize有什么区别？</h3><ul>
<li>final：是修饰符，如果修饰类，此类不能被继承；如果修饰方法和变量，则表示此方法和此变量不能被改变，只能使用。</li>
<li>finally：是t异常捕获结构的最后一部分，可以省略，若存在，则一定会执行finally里面的代码。</li>
<li>finalize：是Object类的一个方法，在垃圾收集器执行的过程中会调用被回收对象的此方法。</li>
</ul>
<h3 id="15-public、private、protected的区别，继承方法与访问权限"><a href="#15-public、private、protected的区别，继承方法与访问权限" class="headerlink" title="15. public、private、protected的区别，继承方法与访问权限"></a>15. public、private、protected的区别，继承方法与访问权限</h3><table>
<thead>
<tr>
<th></th>
<th>类内部</th>
<th>本包</th>
<th>子类</th>
<th>外部包</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>protected</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>✓</td>
<td>✓</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>private</td>
<td>✓</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<h2 id="设计模式篇"><a href="#设计模式篇" class="headerlink" title="设计模式篇"></a>设计模式篇</h2><h3 id="1-说下代理模式"><a href="#1-说下代理模式" class="headerlink" title="1. 说下代理模式?"></a>1. 说下代理模式?</h3><p>简单来说就是使用代理对象对目标对象进行访问, 这样就可以在不修改目标对象的情况下对目标对象做一些增强操作.</p>
<h2 id="容器篇"><a href="#容器篇" class="headerlink" title="容器篇"></a>容器篇</h2><h3 id="1-HashMap和HashTable的区别"><a href="#1-HashMap和HashTable的区别" class="headerlink" title="1. HashMap和HashTable的区别"></a>1. HashMap和HashTable的区别</h3><ul>
<li>JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间（后文中我会结合源码对这一过程进行分析）。Hashtable 没有这样的机制。</li>
<li>Hashtable是不能存储null的key和value</li>
<li>HashTable内部的方法是synchronized修饰是线程安全的</li>
</ul>
<h3 id="2-HashMap、TreeMap、LinkedHashMap三者的相同点和不同点"><a href="#2-HashMap、TreeMap、LinkedHashMap三者的相同点和不同点" class="headerlink" title="2. HashMap、TreeMap、LinkedHashMap三者的相同点和不同点"></a>2. HashMap、TreeMap、LinkedHashMap三者的相同点和不同点</h3><p>相同点：</p>
<ol>
<li>三者在特定的情况下，都会使用红黑树；</li>
<li>底层的 hash 算法相同；</li>
<li>在迭代的过程中，如果 Map 的数据结构被改动，都会报 ConcurrentModificationException 的错误。</li>
</ol>
<p>不同点：</p>
<ol>
<li>HashMap 数据结构以数组为主，查询非常快，TreeMap 数据结构以红黑树为主，利用了红黑树左小右大的特点，可以实现 key 的排序，LinkedHashMap 在 HashMap 的基础上增加了链表的结构，实现了插入顺序访问和最少访问删除两种策略;</li>
<li>由于三种 Map 底层数据结构的差别，导致了三者的使用场景的不同，TreeMap 适合需要根据 key 进行排序的场景，LinkedHashMap 适合按照插入顺序访问，或需要删除最少访问元素的场景，剩余场景我们使用 HashMap 即可，我们工作中大部分场景基本都在使用 HashMap；</li>
<li>由于三种 map 的底层数据结构的不同，导致上层包装的 api 略有差别。</li>
</ol>
<h3 id="3-HashMap是如何扩容的？"><a href="#3-HashMap是如何扩容的？" class="headerlink" title="3. HashMap是如何扩容的？"></a>3. HashMap是如何扩容的？</h3><ol>
<li>put 时，发现数组为空，进行初始化扩容，默认扩容大小为 16;</li>
<li>put 成功后，发现现有数组大小大于扩容的门阀值时，进行扩容，扩容为老数组大小的 2 倍;</li>
</ol>
<p>扩容的门阀是 threshold，每次扩容时 threshold 都会被重新计算，门阀值等于数组的大小 * 影响因子（0.75）。</p>
<p>新数组初始化之后，需要将老数组的值拷贝到新数组上，链表和红黑树都有自己拷贝的方法。</p>
<h3 id="4-hash冲突了怎么办？"><a href="#4-hash冲突了怎么办？" class="headerlink" title="4. hash冲突了怎么办？"></a>4. hash冲突了怎么办？</h3><p>hash 冲突指的是 key 值的 hashcode 计算相同，但 key 值不同的情况。</p>
<p>如果桶中元素原本只有一个或已经是链表了，新增元素直接追加到链表尾部；</p>
<p>如果桶中元素已经是链表，并且链表个数大于等于 8 时，此时有两种情况：</p>
<ol>
<li>如果此时数组大小小于 64，数组再次扩容，链表不会转化成红黑树;</li>
<li>如果数组大小大于 64 时，链表就会转化成红黑树。</li>
</ol>
<p>这里不仅仅判断链表个数大于等于 8，还判断了数组大小，数组容量小于 64 没有立即转化的原因，猜测主要是因为红黑树占用的空间比链表大很多，转化也比较耗时，所以数组容量小的情况下冲突严重，我们可以先尝试扩容，看看能否通过扩容来解决冲突的问题。</p>
<h3 id="5-HashSet如何查重的？"><a href="#5-HashSet如何查重的？" class="headerlink" title="5. HashSet如何查重的？"></a>5. HashSet如何查重的？</h3><p>当把对象加入HashSet时，会先计算对象的hashcode的值来判断对象加入的位置，同时也会和其他加入的对象的hashcode进行比较，如果发现相同的hashcode，就会调用equals()方法来检查对象是否真的相同。如果相同，HashSet就不会让其加入成功。</p>
<h3 id="6-如何选择HashMap和TreeMap？"><a href="#6-如何选择HashMap和TreeMap？" class="headerlink" title="6. 如何选择HashMap和TreeMap？"></a>6. 如何选择HashMap和TreeMap？</h3><p>对于在Map中插入、删除、定位一个元素这类操作，HashMap是最好的选择，因为相对而言HashMap的插入就会更快，但如果你要对一个key集合进行有序的遍历，那TreeMap是更好的。</p>
<h3 id="7-说下HashMap实现原理？"><a href="#7-说下HashMap实现原理？" class="headerlink" title="7. 说下HashMap实现原理？"></a>7. 说下HashMap实现原理？</h3><p>这个问题要从底层说起，hashmap在jdk7和jdk8就有区别。</p>
<ol>
<li><strong>首先从数据结构来</strong>说，jdk7HashMap主要是使用的数组和链表，而jdk8的HashMap主要使用的是数组链表加红黑树。</li>
<li><strong>然后数据结构的转化</strong>，红黑树和链表会互相转换，当数组大小大于64并且链表大小大于8就会转换为红黑树，红黑树的长度小于6就会又转换为链表。</li>
<li><strong>接着分析扩容机制</strong>，hashmap中的负载因子为0.75，默认容量为16，当存储数组大小大于默认容量*负载因子就会扩容为原来的2倍。jdk7在put的方法使用的头插法，而jdk8是用到尾插法。但是会出现一些<strong>线程安全问题</strong>，比如两个线程同时扩容的话，就会造成循环链表</li>
</ol>
<h3 id="8-说说ConcurrentHashMap的底层结构"><a href="#8-说说ConcurrentHashMap的底层结构" class="headerlink" title="8. 说说ConcurrentHashMap的底层结构"></a>8. 说说ConcurrentHashMap的底层结构</h3><ul>
<li>jdk7中ConcurrentHashMap的底层是最外层是segment，每个segment底层数据结构跟HashMap差不多，也是数组链表。每个segment有独立的ReentrantLock锁，每个segment互相不影响，提高了并发效率。ConcurrentHashMap默认有16个segment，一旦初始化就不能扩容了。</li>
<li>jdk8中和HashMap的底层结构差不多，多了转移结点，就是为了保证扩容的并发安全。红黑树的结构也有点不同，新增了TreeBin来维护红黑树的结构，并负责根节点的加锁和解锁。</li>
</ul>
<h3 id="9-说说HashMap和ConcurrentHashMap的区别？"><a href="#9-说说HashMap和ConcurrentHashMap的区别？" class="headerlink" title="9. 说说HashMap和ConcurrentHashMap的区别？"></a>9. 说说HashMap和ConcurrentHashMap的区别？</h3><p>相同点：</p>
<ol>
<li><p>底层的数据结构都差不多一样 </p>
</li>
<li><p>都继承了AbstractMap类，所以HashMap有的方法和ConcurrentHashMap几乎都有</p>
</li>
</ol>
<p>不同点：</p>
<ol>
<li>红黑树结构略有不同，HashMap 的红黑树中的节点叫做 TreeNode，TreeNode 不仅仅有属性，还维护着红黑树的结构，比如说查找，新增等等；ConcurrentHashMap 中红黑树被拆分成两块，TreeNode 仅仅维护的属性和查找功能，新增了 TreeBin，来维护红黑树结构，并负责根节点的加锁和解锁；</li>
<li>新增 ForwardingNode （转移）节点，扩容的时候会使用到，通过使用该节点，来保证扩容时的线程安全。</li>
</ol>
<h3 id="10-说说ConcurrentHashMap的put操作？"><a href="#10-说说ConcurrentHashMap的put操作？" class="headerlink" title="10. 说说ConcurrentHashMap的put操作？"></a>10. 说说ConcurrentHashMap的put操作？</h3><p>ConcurrentHashMap 在 put 方法上的整体思路和 HashMap 相同，但在线程安全方面写了很多保障的代码，我们先来看下大体思路：</p>
<ol>
<li><p>如果数组为空就初始化</p>
</li>
<li><p>根据计算得到的hashcode找到对应的索引位置的槽点</p>
</li>
<li><p>判断这个槽点如果这个槽点为空的话</p>
</li>
<li><ol>
<li>用CAS创建，失败就一直自旋创建，直到创建成功</li>
</ol>
</li>
<li><p>这个槽点如果有值的话</p>
</li>
<li><ul>
<li>先锁定这个槽点，不让其他线程干扰</li>
<li>如果是转移结点（move），说明在扩容，等待其扩容完了，在进行操作</li>
<li>如果是链表，新增到链表尾部</li>
<li>如果是红黑树，就用红黑树的新增方式</li>
</ul>
</li>
<li><p>put执行完了要检查一下是否需要扩容，如果需要就扩容</p>
</li>
</ol>
<h3 id="11-说说ConcurrentHashMap如何保证线程安全的？"><a href="#11-说说ConcurrentHashMap如何保证线程安全的？" class="headerlink" title="11. 说说ConcurrentHashMap如何保证线程安全的？"></a>11. 说说ConcurrentHashMap如何保证线程安全的？</h3><blockquote>
<p>数组初始化</p>
</blockquote>
<p>采用<strong>CAS、自旋、双重判断</strong>的方式：</p>
<p>数组初始化的时候，自旋来保证一定可以初始化成功，用CAS来设置SIZECTL变量来保证同一时刻只能有一个数组被一个线程给初始化，初始化成功后还会在检查一下是否初始化成功。</p>
<blockquote>
<p> put操作保证线程安全：</p>
</blockquote>
<ul>
<li>通过自旋死循环保证一定可以新增成功。</li>
</ul>
<p>在新增之前，通过 for (Node&lt;K,V&gt;[] tab &#x3D; table;;) 这样的死循环来保证新增一定可以成功，一旦新增成功，就可以退出当前死循环，新增失败的话，会重复新增的步骤，直到新增成功为止。</p>
<ul>
<li>当前槽点为空时，通过 CAS 新增。</li>
</ul>
<p>Java 这里的写法非常严谨，没有在判断槽点为空的情况下直接赋值，因为在判断槽点为空和赋值的瞬间，很有可能槽点已经被其他线程赋值了，所以我们采用 CAS 算法，能够保证槽点为空的情况下赋值成功，如果恰好槽点已经被其他线程赋值，当前 CAS 操作失败，会再次执行 for 自旋，再走槽点有值的 put 流程，这里就是自旋 + CAS 的结合。</p>
<ul>
<li>当前槽点有值，锁住当前槽点。</li>
</ul>
<p>put 时，如果当前槽点有值，就是 key 的 hash 冲突的情况，此时槽点上可能是链表或红黑树，我们通过锁住槽点，来保证同一时刻只会有一个线程能对槽点进行修改</p>
<ul>
<li>红黑树旋转时，锁住红黑树的根节点，保证同一时刻，当前红黑树只能被一个线程旋转</li>
</ul>
<blockquote>
<p> 扩容时的线程安全：</p>
</blockquote>
<ol>
<li>拷贝槽点时，会把原数组的槽点锁住；</li>
<li>拷贝成功之后，会把原数组的槽点设置成转移节点，这样如果有数据需要 put 到该节点时，发现该槽点是转移节点，会一直等待，直到扩容成功之后，才能继续 put，可以参考 put 方法中的 helpTransfer 方法；</li>
<li>从尾到头进行拷贝，拷贝成功就把原数组的槽点设置成转移节点。</li>
<li>等扩容拷贝都完成之后，直接把新数组的值赋值给数组容器，之前等待 put 的数据才能继续 put</li>
</ol>
<h3 id="12-现在我有一个很大的数组需要拷贝，原数组大小是-5k，请问如何快速拷贝？"><a href="#12-现在我有一个很大的数组需要拷贝，原数组大小是-5k，请问如何快速拷贝？" class="headerlink" title="12. 现在我有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝？"></a>12. 现在我有一个很大的数组需要拷贝，原数组大小是 5k，请问如何快速拷贝？</h3><p>因为原数组比较大，如果新建新数组的时候，不指定数组大小的话，就会频繁扩容，频繁扩容就会有大量拷贝的工作，造成拷贝的性能低下，所以回答说新建数组时，指定新数组的大小为 5k 即可。</p>
<h3 id="13-为什么说扩容会消耗性能？"><a href="#13-为什么说扩容会消耗性能？" class="headerlink" title="13. 为什么说扩容会消耗性能？"></a>13. 为什么说扩容会消耗性能？</h3><p>扩容底层使用的是 System.arraycopy 方法，会把原数组的数据全部拷贝到新数组上，所以性能消耗比较严重。</p>
<h3 id="14-说下CopyOnWriteArrayList"><a href="#14-说下CopyOnWriteArrayList" class="headerlink" title="14. 说下CopyOnWriteArrayList?"></a>14. 说下CopyOnWriteArrayList?</h3><p>CopyOnWriteArrayList底层添加元素是通过复制数组来实现的, 在add方法中会先加一个锁, 然后复制数组, 再添加元素到数组中, 最后会将指向新的数组</p>
<blockquote>
<p>优点</p>
</blockquote>
<p>当然是线程安全</p>
<blockquote>
<p>缺点</p>
</blockquote>
<ul>
<li>消耗内存: 每次add都会复制新数组</li>
<li>只能保证数据最终的一致性, 无法保证实时一致性</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1-有哪几种实现多线程的方式？"><a href="#1-有哪几种实现多线程的方式？" class="headerlink" title="1. 有哪几种实现多线程的方式？"></a>1. 有哪几种实现多线程的方式？</h3><ol>
<li>继承Thread类实现Runnable方法 </li>
<li>实现Runnble接口 </li>
<li>实现Callable接口</li>
</ol>
<h3 id="2-实现Runnable接口和继承Thread类哪种方式更好？"><a href="#2-实现Runnable接口和继承Thread类哪种方式更好？" class="headerlink" title="2. 实现Runnable接口和继承Thread类哪种方式更好？"></a>2. 实现Runnable接口和继承Thread类哪种方式更好？</h3><p>实现Runnable接口更好</p>
<p>继承Thread类是不推荐的，因为它有以下的一些缺点：</p>
<ol>
<li>从代码的架构的角度：具体的任务（run方法）应该和“创建和运行线程的机制（Thread类）”解耦，用实现Runnable接口的方式可以实现解耦合。通过Runnable方式实现的run方法中的内容是具体执行的任务，可以让单独的一个任务类实现Runnable接口，然后把对应的实例传入Thread类就可以了。这样的一个任务类，可以传给不同的Thread，并且任务类也不负责创建线程等工作，是解耦合的。</li>
<li>使用继承Thread类的方式的话，那么每次都想要新建一个任务，只能新建一个独立的线程，而这样做的损耗会比较大（比如重头开始创建一个线程、执行完毕以后再销毁等。如果线程的实际工作内容，也就是run()函数里只是简单地打印一行文字的话，那么可能线程的实际工作内容还不如损耗来的大）</li>
</ol>
<p>如果使用Runnable和线程池，就可以大大减少这样的损耗。</p>
<ol>
<li>继承Thread类以后，由于Java语言是不支持双继承的，这样就无法再继承其他的类，限制类可扩展性。通常我们优先选择方法1。</li>
</ol>
<h3 id="3-线程有哪几种状态？生命周期是什么？"><a href="#3-线程有哪几种状态？生命周期是什么？" class="headerlink" title="3. 线程有哪几种状态？生命周期是什么？"></a>3. 线程有哪几种状态？生命周期是什么？</h3><img src="/2022/05/01/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BD%92%E7%BA%B3/image-20220517181700085.png" srcset="/img/loading.gif" lazyload alt="image-20220517181700085" style="zoom:50%;">



<p>六种状态：<strong>NEW</strong>、<strong>RUNNABLE</strong>、<strong>BLOCKED</strong>、<strong>WAITING</strong>、<strong>TIMED_WAiTING</strong>、<strong>TERMINATED</strong></p>
<h3 id="4-实现两个线程交替打印0～100奇偶数"><a href="#4-实现两个线程交替打印0～100奇偶数" class="headerlink" title="4. 实现两个线程交替打印0～100奇偶数"></a>4. 实现两个线程交替打印0～100奇偶数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 描述：     两个线程交替打印0~100的奇偶数，用wait和notify</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotifyPrintOddEveWait</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TurningRunner</span>(), <span class="hljs-string">&quot;偶数&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TurningRunner</span>(), <span class="hljs-string">&quot;奇数&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-comment">//1. 拿到锁，我们就打印</span><br>    <span class="hljs-comment">//2. 打印完，唤醒其他线程，自己就休眠</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TurningRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (count &lt;= <span class="hljs-number">100</span>) &#123;<br>                <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                    <span class="hljs-comment">//拿到锁就打印</span><br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + count++);<br>                    lock.notify();<br>                    <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">100</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-comment">//如果任务还没结束，就让出当前的锁，并休眠</span><br>                            lock.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="5-实现消费者生产者模式"><a href="#5-实现消费者生产者模式" class="headerlink" title="5. 实现消费者生产者模式"></a>5. 实现消费者生产者模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 描述：     用wait/notify来实现生产者消费者模式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerConsumerModel</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">EventStorage</span> <span class="hljs-variable">eventStorage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventStorage</span>();<br>        <span class="hljs-type">Producer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Producer</span>(eventStorage);<br>        <span class="hljs-type">Consumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(eventStorage);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(producer).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(consumer).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> EventStorage storage;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Producer</span><span class="hljs-params">(</span><br><span class="hljs-params">            EventStorage storage)</span> &#123;<br>        <span class="hljs-built_in">this</span>.storage = storage;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            storage.put();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> EventStorage storage;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(</span><br><span class="hljs-params">            EventStorage storage)</span> &#123;<br>        <span class="hljs-built_in">this</span>.storage = storage;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            storage.take();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventStorage</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxSize;<br>    <span class="hljs-keyword">private</span> LinkedList&lt;Date&gt; storage;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">EventStorage</span><span class="hljs-params">()</span> &#123;<br>        maxSize = <span class="hljs-number">10</span>;<br>        storage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (storage.size() == maxSize) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        storage.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        System.out.println(<span class="hljs-string">&quot;仓库里有了&quot;</span> + storage.size() + <span class="hljs-string">&quot;个产品。&quot;</span>);<br>        notify();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (storage.size() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;拿到了&quot;</span> + storage.poll() + <span class="hljs-string">&quot;，现在仓库还剩下&quot;</span> + storage.size());<br>        notify();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="6-wait、sleep的异同"><a href="#6-wait、sleep的异同" class="headerlink" title="6. wait、sleep的异同"></a>6. wait、sleep的异同</h3><p>相同点：1.都会堵塞线程  2.都能响应中断   </p>
<p>不同点：</p>
<p>1.wait是声明在Object中的方法；sleep是声明在Thread类中的方法 </p>
<p>2.wait只能放在同步代码块中或者同步方法中；sleep是任何地方都可以 </p>
<p>3.wait会释放锁而sleep不会释放锁</p>
<h3 id="7-在join期间线程处于什么状态？"><a href="#7-在join期间线程处于什么状态？" class="headerlink" title="7. 在join期间线程处于什么状态？"></a>7. 在join期间线程处于什么状态？</h3><p>处于waiting状态</p>
<h3 id="8-守护线程和普通线程的区别？"><a href="#8-守护线程和普通线程的区别？" class="headerlink" title="8. 守护线程和普通线程的区别？"></a>8. 守护线程和普通线程的区别？</h3><p>守护线程和普通线程几乎是没有区别的，唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出了，只剩下守护线程存在了，那虚拟机就退出了，这是因为没有了“被守护者”，守护线程就没有工作可以做了，也就是没有继续运行程序的必要了。</p>
<h3 id="9-我们是否需要给线程设置守护线程？"><a href="#9-我们是否需要给线程设置守护线程？" class="headerlink" title="9. 我们是否需要给线程设置守护线程？"></a>9. 我们是否需要给线程设置守护线程？</h3><p>我们通常不应该把自己的线程设置为守护线程，因为设置为守护线程是很危险的。比如线程正在访问如文件、数据库的时候，所以用户线程都结束了，那么守护线程会在任何时候甚至在一个操作的中间发生中断。</p>
<h3 id="10-说说单例模式的多种写法？"><a href="#10-说说单例模式的多种写法？" class="headerlink" title="10. 说说单例模式的多种写法？"></a>10. 说说单例模式的多种写法？</h3><blockquote>
<p>饿汉式</p>
</blockquote>
<p>1.静态代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-keyword">static</span> &#123;<br>    	instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <br>   	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    	<span class="hljs-keyword">return</span> intance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>2.静态常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    	<span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<blockquote>
<p>懒汉式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    	<span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>)&#123;<br>        	instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    	<span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>)&#123;<br>        	instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<blockquote>
<p><strong><span style="color:red;">双重检查</span></strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    	<span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>)&#123;<br>        	<span class="hljs-keyword">synchronized</span>(Singleton.class)&#123;<br>            	<span class="hljs-keyword">if</span>(instance != <span class="hljs-literal">null</span>)&#123;<br>                	instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>为什么要用volatile关键字修饰instance呢？</p>
<p>因为new一个对象的步骤为先为对象分配空间、执行构造器给成员变量赋值、将对象指向堆中的空间（执行了这一步对象就不为null了）。但是由于JVM编译器中存在重排序的方法来进行优化，new的步骤是可能不是按照正常的顺序的。如果第三个步骤先于步骤2执行里面的成员变量就会没有初始化。线程2第一重判断就进不来就直接返回instance了，但此时的instance中的成员变量就没有初始化。但是要注意的是：如果线程1把synchronized代码块的内容执行了，由于happens-before原则，此时instance一定是正确构造后的实例。</p>
<p>静态内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton2</span> &#123;<br>    	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    	<span class="hljs-keyword">return</span> Singleton2.instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>枚举：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singleton</span>&#123;<br>	INSTANCE; <br>&#125;<br></code></pre></td></tr></table></figure>







<h3 id="11-什么是happens-before原则"><a href="#11-什么是happens-before原则" class="headerlink" title="11. 什么是happens-before原则?"></a>11. 什么是happens-before原则?</h3><p>happens-before规则是用来解决可见性问题的：在时间上，动作A发生在动作B之前，B保证能看到A的动作，这就是happens-before。</p>
<h3 id="12-happens-before有哪些规则？"><a href="#12-happens-before有哪些规则？" class="headerlink" title="12. happens-before有哪些规则？"></a>12. happens-before有哪些规则？</h3><ol>
<li><p>单线程规则：单个线程的两个操作，如果操作2能看到操作1的操作。</p>
</li>
<li><p>锁操作：比如一个线程进入同步代码块，另一个线程在等待，前一个线程解锁后，后一个线程进入锁，这个线程可以看见前一个线程的操作。</p>
</li>
<li><p>volatile变量：假设A是对volatile变量的写操作，B是对这个变量的读操作，那么B是可以看见A的所以操作。</p>
</li>
</ol>
<h3 id="13-讲讲Volatile关键字"><a href="#13-讲讲Volatile关键字" class="headerlink" title="13. 讲讲Volatile关键字?"></a>13. 讲讲Volatile关键字?</h3><p><strong>什么是Volatile关键字？</strong></p>
<ol>
<li><p><strong>volatile</strong>是一种<strong>同步机制</strong>，比<strong>synchronized</strong>或者<strong>Lock</strong>相关类更加轻量，因此使用<strong>volatile</strong>并不会发生上下文切换等开销大的行为。</p>
</li>
<li><p>但是开销小，相应的能力也小，虽然说<strong>volatile</strong>用来同步的保证线程安全的，但是<strong>volatile</strong>属性的读写操作是无锁的，不能完全替代<strong>synchronized</strong>或者<strong>Lock</strong>，因为它没有提供原子性和互斥性，<strong>volatile</strong>仅在有限的场景下才能发挥作用。</p>
</li>
<li><p><strong>Volatile</strong>只能修饰属性，这样编译器就不会对这个属性进行指令的<strong>重排序</strong></p>
</li>
<li><p>volatile<strong>提供了可见性，任何一个线程对其修饰的属性进行修改将立马对其他线程所见。</strong>volatile<strong>属性不会被本地线程缓存，始终从主内存中读取。操作的数据直接存入主内存</strong></p>
</li>
</ol>
<h3 id="14-volatile和synchronized的异同？"><a href="#14-volatile和synchronized的异同？" class="headerlink" title="14. volatile和synchronized的异同？"></a>14. volatile和synchronized的异同？</h3><ul>
<li>volatile修饰的属性本质上是告诉JVM这个属性可能会被并发修改，而synchronized则是会锁定当前的变量，只有当前的线程可以访问此变量，而其他线程会被阻塞住。</li>
<li>volatile仅能修饰在变量上；而synchronized则可以使用在变量、方法、类上</li>
<li>volatile仅能保证变量修改的可见性，不能保证原子性；而sychronized则可以保证变量的修改可见性和原子性</li>
<li>volatile修饰的变量不会被编译器重排序；而synchronized标记的变量则可以被编译器重排序</li>
</ul>
<h3 id="15-什么是内存可见性问题？"><a href="#15-什么是内存可见性问题？" class="headerlink" title="15. 什么是内存可见性问题？"></a>15. 什么是内存可见性问题？</h3><p>为了提高CPU的运行效率，CPU内加入了高速缓存，高速缓存的容量比内存小，但是速度仅次于寄存器，所以在CPU和内存之间就多了Cache层，导致了多线程时很多问题的发生。</p>
<p>线程间的对于共享变量的可见性问题不是直接由多核引起的，而是由多缓存引起的。如果所有核心都只用一个缓存，那么就不存在可见性问题了。</p>
<p>现代多核CPU中每个核心拥有自己的一级缓存或者一级缓存加上二级缓存，问题就发生在每个核心的独占缓存上。每个核心都会将自己需要的数据读取到独占缓存中，数据修改后也是写入到缓存中，然后等待刷入到主存中。所以导致有些核心读取的值是一个过期的值。</p>
<h3 id="16-主内存和本地内存的关系？"><a href="#16-主内存和本地内存的关系？" class="headerlink" title="16. 主内存和本地内存的关系？"></a>16. 主内存和本地内存的关系？</h3><p>所有共享的变量存在于内存中，每个线程都有自己的本地内存，而且线程读写共享数据也是通过本地内存交换的，所以才导致了可见性问题。</p>
<h3 id="17-Java中的原子操作有哪些？"><a href="#17-Java中的原子操作有哪些？" class="headerlink" title="17. Java中的原子操作有哪些？"></a>17. Java中的原子操作有哪些？</h3><ol>
<li>除了<strong>long</strong>和<strong>double</strong>之外的基本类型的赋值操作。</li>
<li>**java.concurrent.Atomic.***包中所有类的原子操作 </li>
<li><strong>所有引用的赋值操作</strong></li>
</ol>
<h3 id="18-写一个必然死锁的例子？"><a href="#18-写一个必然死锁的例子？" class="headerlink" title="18. 写一个必然死锁的例子？"></a>18. 写一个必然死锁的例子？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MustDeathLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> flag;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;获取到了锁1&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    wait(<span class="hljs-number">500</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;获取到了锁2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;获取到了锁2&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    wait(<span class="hljs-number">500</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;获取到了锁1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MustDeathLock</span> <span class="hljs-variable">mustDeathLock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MustDeathLock</span>();<br>        <span class="hljs-type">MustDeathLock</span> <span class="hljs-variable">mustDeathLock2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MustDeathLock</span>();<br><br>        mustDeathLock1.flag = <span class="hljs-number">0</span>;<br>        mustDeathLock2.flag = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mustDeathLock1);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(mustDeathLock2);<br><br><br>        thread1.start();<br>        thread2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>







<h3 id="19-什么是死锁？"><a href="#19-什么是死锁？" class="headerlink" title="19. 什么是死锁？"></a>19. 什么是死锁？</h3><p>死锁是指两个或两个以上的进程在执行的过程中，由于竞争资源或者由于彼此通信而造成的一种堵塞的现象，若无外力作用，它们都将无法推进下</p>
<h3 id="20-什么是线程安全？如何理解？"><a href="#20-什么是线程安全？如何理解？" class="headerlink" title="20. 什么是线程安全？如何理解？"></a>20. 什么是线程安全？如何理解？</h3><p>假设同一个进程由多个线程执行，如果每次执行的结果都和单线程处理结果一样而且变量的值和我们预测的一样的话，就是线程安全的。</p>
<h3 id="21-实现线程安全的方式？"><a href="#21-实现线程安全的方式？" class="headerlink" title="21. 实现线程安全的方式？"></a>21. 实现线程安全的方式？</h3><p>互斥同步：synchronized和ReentrantLock</p>
<p>非阻塞同步：CAS，AtomicXXX、volatile</p>
<p>无同步方案：ThreadLocal、栈封闭、可重入代码</p>
<h3 id="22-说说Unsafe类？"><a href="#22-说说Unsafe类？" class="headerlink" title="22. 说说Unsafe类？"></a>22. 说说Unsafe类？</h3><p>Unsafe是CAS的核心类。Java无法直接访问底层操作系统，而是通过本地（native）方法来访问的。不过如此，JVM还是开了一个后门，JDK中有一个类	Unsafe，它提供了硬件级别的原子操作。</p>
<h3 id="23-说下synchronized原理"><a href="#23-说下synchronized原理" class="headerlink" title="23. 说下synchronized原理?"></a>23. 说下synchronized原理?</h3><p>synchronized同步语句的实现是monitorenter和monitorexit。其中monitorenter是指向同步代码中开始的部分，而monitorexit是指向同步代码中结束的部分。当执行monitorenter的时候先去获取对象的锁，如果对象锁的计算器为0则可以获取成功，获取后将计数器加1。对象锁的拥有线程才可以执行monitorexit，执行后将计数器减1。</p>
<h3 id="24-并行和并发有什么区别？"><a href="#24-并行和并发有什么区别？" class="headerlink" title="24. 并行和并发有什么区别？"></a>24. 并行和并发有什么区别？</h3><ul>
<li>并行：多核或者多个处理器同时处理多个任务。</li>
<li>并发：多个任务在同一个CPU核上，按划分的时间片轮流执行，从逻辑上来看是同时执行的。</li>
</ul>
<h3 id="25-线程和进程的区别？"><a href="#25-线程和进程的区别？" class="headerlink" title="25. 线程和进程的区别？"></a>25. 线程和进程的区别？</h3><ul>
<li>进程是资源分配的基本单位</li>
<li>线程是资源调度的基本单位</li>
</ul>
<h3 id="26-创建线程池有哪几种方式？"><a href="#26-创建线程池有哪几种方式？" class="headerlink" title="26. 创建线程池有哪几种方式？"></a>26. 创建线程池有哪几种方式？</h3><ol>
<li>可以使用Executors来创建，常见的有newFixedThreadPool、newSingleThreadPool、newCacheThreadPool、newScheduledThreadPool</li>
<li>使用ThreadPoolExecutor创建，各种参数需要自己配置。</li>
</ol>
<h3 id="27-线程池的状态"><a href="#27-线程池的状态" class="headerlink" title="27. 线程池的状态"></a>27. 线程池的状态</h3><ul>
<li>RUNNING：这是最正常的状态，接受新的任务，处理等待队列中的任务。</li>
<li>SHUTDOWN：不接受任何新任务提交，但是会继续处理等待队列中的任务。</li>
<li>STOP：不接受任何新任务的提交，不再处理等待队列中的任务，中断当前执行任务的线程</li>
<li>TIDYING：所有任务都销毁了，线程池的状态会转化为TIDYING，然后执行钩子方法terminated()</li>
<li>TERMINATED：terminated()方法结束后，线程池的状态就会变化为这个</li>
</ul>
<h3 id="28-说下atomic的原理"><a href="#28-说下atomic的原理" class="headerlink" title="28. 说下atomic的原理"></a>28. 说下atomic的原理</h3><p>atomic主要利用CAS和volatile和native方法来保证原子操作。</p>
<h3 id="29-说说ThreadLocal的原理？"><a href="#29-说说ThreadLocal的原理？" class="headerlink" title="29. 说说ThreadLocal的原理？"></a>29. 说说ThreadLocal的原理？</h3><p>每个线程内部都维护了一个ThreadLocalMap，它是一个Map（key,value）数据格式，key是一个弱引用，也就是ThreadLocal本身，而value存的是线程变量的值。也就是说ThreadLocal本身并不存储线程的变量值，它只是一个工具，用来维护线程内部的Map，帮助存和取变量。</p>
<h3 id="30-ThreadLocal的内存泄漏是怎么回事？"><a href="#30-ThreadLocal的内存泄漏是怎么回事？" class="headerlink" title="30. ThreadLocal的内存泄漏是怎么回事？"></a>30. ThreadLocal的内存泄漏是怎么回事？</h3><p>ThreadLocal在ThreadLocalMap中是以一个弱引用身份被Entry中的key引用的，因此如果ThreadLocal没有外部强引用来引用它，那么ThreadLocal会在下次JVM垃圾回收器时被垃圾回收。这个时候Entry中的key已经被回收了，但是value又是一强引用不会被垃圾收集器回收，这样ThreadLocal的线程如果一直持续运行，value就一直得不到回收，这样就会发生内存泄漏。</p>
<h3 id="31-线程池添加线程的规则？"><a href="#31-线程池添加线程的规则？" class="headerlink" title="31. 线程池添加线程的规则？"></a>31. 线程池添加线程的规则？</h3><p>先判断核心线程数是否被占满，如果没有占满就直接常见核心线程执行任务，如果占满了，又判断工作队列是否是满的，如果不是满的就添加到队列中。是满的的话就添加后是否超出了最大线程数，没有的话就创建非核心线程的任务。是的话就拒绝。</p>
<h3 id="32-说说常见的乐观锁和悲观锁？"><a href="#32-说说常见的乐观锁和悲观锁？" class="headerlink" title="32. 说说常见的乐观锁和悲观锁？"></a>32. 说说常见的乐观锁和悲观锁？</h3><ul>
<li>乐观锁主要有：CAS以及各种原子类</li>
<li>悲观锁主要有：Lock下的类、synchronized</li>
</ul>
<h3 id="33-讲下CAS"><a href="#33-讲下CAS" class="headerlink" title="33. 讲下CAS?"></a>33. 讲下CAS?</h3><ul>
<li>CAS有三个操作数: 当前值、内存值、修改值<ul>
<li>如果当前值跟内存值相等则将内存值改为修改值</li>
<li>如果当前值跟内存值不相等则重试</li>
</ul>
</li>
<li>将当前值与内存值进行对比, 判断是否有被修改过, 这就是CAS核心</li>
</ul>
<h2 id="web篇"><a href="#web篇" class="headerlink" title="web篇"></a>web篇</h2><h3 id="1-什么是cookie、session、token？"><a href="#1-什么是cookie、session、token？" class="headerlink" title="1. 什么是cookie、session、token？"></a>1. 什么是cookie、session、token？</h3><ol>
<li>cookie是保存在客户端的一种数据结构。一般是用来缓存数据。</li>
<li>session是保存在服务端的一种数据结构。一般缓存了用户信息。客户端关闭就会失效。是基于cookie工作的，一般来说，想要维持客户端和服务器的状态，就需要基于cookie保存到客户端，name为JSESSIONID</li>
<li>token也叫做令牌，是服务器生成的一串字符串，最为客户端进行请求的一个标识。token存在哪里都可以，客户端可存入在localstorage或者cookie中，而服务端则存放中数据库中（服务端的session是直接存入内存中的）</li>
</ol>
<h3 id="2-分布式Session的几种解决方案？"><a href="#2-分布式Session的几种解决方案？" class="headerlink" title="2. 分布式Session的几种解决方案？"></a>2. 分布式Session的几种解决方案？</h3><ol>
<li>为每个服务器都更新其session</li>
<li>存入客户端。将session存入cookie中。</li>
<li>使用redis来集中管理session。</li>
</ol>
<h3 id="3-forward和redirect的区别？"><a href="#3-forward和redirect的区别？" class="headerlink" title="3. forward和redirect的区别？"></a>3. forward和redirect的区别？</h3><p>forward是转发和redirect是重定向：</p>
<ul>
<li>地址栏url显示：转发url不会发生改变，重定向会改变</li>
<li>数据共享：转发可以共享request里的内容，重定向不能共享</li>
<li>效率：转发的效率更高</li>
</ul>
<h3 id="4-tcp为什么要三次握手，两次不行吗？为什么？"><a href="#4-tcp为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="4. tcp为什么要三次握手，两次不行吗？为什么？"></a>4. tcp为什么要三次握手，两次不行吗？为什么？</h3><p>如果采取两次握手，那么只要服务器发出确认数据包就会建立连接，但由于客户端此时并未响应服务器端的请求，那此时服务器端就会一直在等待客户端，这样服务器端就会白白浪费了一定的资源。</p>
<h3 id="5-怎么实现跨域？"><a href="#5-怎么实现跨域？" class="headerlink" title="5. 怎么实现跨域？"></a>5. 怎么实现跨域？</h3><ul>
<li>在接口上使用注解@CrossOrigin运行跨域</li>
<li>修改nginx配置文件</li>
</ul>
<h3 id="6-如果客户端禁止cookie能实现session还能用吗？"><a href="#6-如果客户端禁止cookie能实现session还能用吗？" class="headerlink" title="6. 如果客户端禁止cookie能实现session还能用吗？"></a>6. 如果客户端禁止cookie能实现session还能用吗？</h3><p>可以用，session只是依赖cookie进行存储sessionId，如果cookie禁用了，可以使用url中添加sessionid的方式保证session能够正常使用。</p>
<h3 id="7-什么是XSS攻击，如何避免？"><a href="#7-什么是XSS攻击，如何避免？" class="headerlink" title="7. 什么是XSS攻击，如何避免？"></a>7. 什么是XSS攻击，如何避免？</h3><ul>
<li>XSS攻击：即跨站脚本攻击，它是web程序中常见的漏洞。原理是攻击者往web页面里插入恶意的脚本代码（css代码、js代码等），当用户浏览该页面时，嵌入其中的代码会被执行，从而达到恶意攻击用户的行为。</li>
<li>预防XSS的核心是必须对输入的数据进行过滤处理</li>
</ul>
<h3 id="8-什么是CSRF攻击，如何避免？"><a href="#8-什么是CSRF攻击，如何避免？" class="headerlink" title="8. 什么是CSRF攻击，如何避免？"></a>8. 什么是CSRF攻击，如何避免？</h3><p>CSRF：Cross-Site Request Forgery（跨站请求伪造），可以理解为攻击者盗用了你的身份，以你的身份进行发送恶意的请求，比如：以你的名义发送邮件、消息、购买商品等。</p>
<p>防御手段：</p>
<ul>
<li>验证请求来源地址</li>
<li>关键操作添加验证码</li>
<li>在请求地址添加token并验证</li>
</ul>
<h2 id="网络篇"><a href="#网络篇" class="headerlink" title="网络篇"></a>网络篇</h2><h3 id="1-说说常见的相应码？"><a href="#1-说说常见的相应码？" class="headerlink" title="1. 说说常见的相应码？"></a>1. 说说常见的相应码？</h3><ul>
<li>2xx：表示服务器处理请求成功。</li>
<li>301：永久重定向，表示资源的url路径已经永久被改变了</li>
<li>302：临时重定向，表示资源还存在，但是需要用新的url</li>
<li>403：Forbidden，表示资源访问没有权限</li>
<li>404：表示资源找不到</li>
<li>5xx：表示服务器的内部错误</li>
</ul>
<h3 id="2-说说GET、POST的区别？"><a href="#2-说说GET、POST的区别？" class="headerlink" title="2. 说说GET、POST的区别？"></a>2. 说说GET、POST的区别？</h3><ul>
<li>GET是幂等的并且安全。POST都不是</li>
<li>GET是请求获取指定URL资源。POST是向指定URL上传数据，数据在报文中的body中</li>
</ul>
<h3 id="3-说说浏览器输入网址到返回页面的过程？"><a href="#3-说说浏览器输入网址到返回页面的过程？" class="headerlink" title="3. 说说浏览器输入网址到返回页面的过程？"></a>3. 说说浏览器输入网址到返回页面的过程？</h3><ol>
<li>DNS解析：比如你在域名注册商那里申请了abc.com，那么你的域名A记录就保存在这个域名注册商的DNS服务器中，该DNS服务器称为权威域名服务器。当客户端访问abc.com时，先查找浏览器DNS缓存，没有则查找操作系统DNS缓存，如果还没有就去查找hosts文件中的域名记录。如果依然没有就去访问电脑设置的DNS服务器IP，比如三大运营商的dns服务器，这一层也被称为野生DNS服务器，也就是非权威域名服务器。如果没有非权威域名服务器就会直接查找根域名服务器-顶级域名服务器-二级域名服务器-权威服务器，这样就找到了abc.com对应的ip了。</li>
</ol>
<p>总结：</p>
<p>DNS解析：1. 先去查找浏览器缓存 2.计算机系统DNS缓存 3.查找hosts域名映射 4.查找电脑设置的非权威DNS服务器ip 5.根域名-顶级域名服务器-二级域名服务器-权威服务器这样逐层地查找</p>
<ol start="2">
<li>浏览器和网站建立TCP连接（TCP三次握手）</li>
</ol>
<p>浏览器发出TCP（SYN&#x3D;1，ACK&#x3D;0）连接请求，主机返回TCP（SYN&#x3D;1，ACK&#x3D;1）应答报文，浏览器收到应答报文，浏览器收到应道报文ACK标志为1，表示连接请求确认。</p>
<p>浏览器返回TCP（ACK&#x3D;1）确认报文，主机收到确认报文，且ACK标志为1，TCP连接建立完成。</p>
<ol start="3">
<li>浏览器发生GET请求</li>
<li>返回页面</li>
</ol>
<h2 id="框架篇"><a href="#框架篇" class="headerlink" title="框架篇"></a>框架篇</h2><h3 id="Spring-Spring-Mvc"><a href="#Spring-Spring-Mvc" class="headerlink" title="Spring&#x2F;Spring Mvc"></a>Spring&#x2F;Spring Mvc</h3><h4 id="1-说说AOP和AspectJ的区别？"><a href="#1-说说AOP和AspectJ的区别？" class="headerlink" title="1. 说说AOP和AspectJ的区别？"></a>1. 说说AOP和AspectJ的区别？</h4><p>答：AOP是运行时增强，而AspectJ是编译时增强。AOP是基于代理的，而AspectJ基于字节码。</p>
<h4 id="2-Spring中bean的作用域有哪些？"><a href="#2-Spring中bean的作用域有哪些？" class="headerlink" title="2. Spring中bean的作用域有哪些？"></a>2. Spring中bean的作用域有哪些？</h4><ul>
<li>singleton：Spring中的bean默认都是单例的。</li>
<li>prototype：每次请求都会创建一个新的bean事例</li>
<li>request：每一次HTTP请求都会产生一个新的bean，该bean仅在当前的HTTP request内有效</li>
<li>session：每一次HTTP请求都会产生一个新的bean，该bean仅在HTTP session内有效</li>
</ul>
<h4 id="3-Spring事务有哪几种传播事务的方式？"><a href="#3-Spring事务有哪几种传播事务的方式？" class="headerlink" title="3. Spring事务有哪几种传播事务的方式？"></a>3. Spring事务有哪几种传播事务的方式？</h4><p>支持当前事务的：</p>
<ul>
<li>TransactionDefinition.PROPAGATION_<strong>REQUIRED</strong>：如果当前有事务则加入，没有就创建</li>
<li>TransactionDefinition.PROPAGATION_<strong>SUPPORT</strong>：如果当前有事务则加入，没有就按照非事务的处理方式</li>
<li>TransactionDefinition.PROPAGATION_<strong>MANDATORY</strong>：如果当前有事务就加入，没有就抛出异常</li>
</ul>
<p>不支持当前事务的：</p>
<ul>
<li>TransactionDefinition.PROPAGATION_<strong>REQUIRES_NEW</strong>：如果当前有事务则将当前事务挂起，创建一个新事务</li>
<li>TransactionDefinition.PROPAGATION_<strong>NOT_SUPPORTED</strong>：如果当前有事务则将当前事务挂起，按照非事务的方式处理</li>
<li>TransactionDefinition.PROPAGATION_<strong>NEVER</strong>：按照非事务的方式处理，如果当前有事务就抛出异常</li>
</ul>
<p>其他情况：</p>
<p>TransactionDefinition.PROPAGATION_<strong>NESTED</strong>：如果当前有事务就新建一个事务嵌套，如果没有就等价于TransactionDefinition.PROPAGATION_REQUIRED</p>
<h4 id="4-对Spring中bean单例线程安全有了解吗？"><a href="#4-对Spring中bean单例线程安全有了解吗？" class="headerlink" title="4. 对Spring中bean单例线程安全有了解吗？"></a>4. 对Spring中bean单例线程安全有了解吗？</h4><p>答：Spring中的bean默认是单例模式的，大部分时候Spring 中的bean是无状态的，所以是线程安全的，但是例如view model对象的bean则是有状态的。解决方法有：1. 将bean的作用域改为prototype 2. 在类中定义ThreadLocal变量，把可变的成员放在里面</p>
<ul>
<li>有状态就是有数据存储功能</li>
<li>无状态就是不会存储数据</li>
</ul>
<h4 id="5-说说Spring-MVC的原理？"><a href="#5-说说Spring-MVC的原理？" class="headerlink" title="5. 说说Spring MVC的原理？"></a>5. 说说Spring MVC的原理？</h4><ol>
<li>客户端发生请求，直接请求到DispatchServlet。</li>
<li>DispatchServlet调用HandlerMapping，handleMapping根据url信息找到对应的Handler。</li>
<li>解析到对应的Handler（也就是我们平常说的Controller控制器）后交给HandlerAdapter适配器处理。</li>
<li>HandlerAdapter会根据Handler来调用真正的处理器来处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回一个ModelAndView对象，Model是返回的数据对象，View是逻辑上的View</li>
<li>ViewResolver会根据逻辑的View查找到实际的View</li>
<li>DispatcherServlet把返回的Model传给View进行视图渲染</li>
<li>把View返回给请求者</li>
</ol>
<h4 id="5-谈谈自己对于-Spring-IoC-的了解"><a href="#5-谈谈自己对于-Spring-IoC-的了解" class="headerlink" title="5. 谈谈自己对于 Spring IoC 的了解"></a>5. 谈谈自己对于 Spring IoC 的了解</h4><p><strong>IoC（Inverse of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p>
<h4 id="6-谈谈自己对于-AOP-的了解"><a href="#6-谈谈自己对于-AOP-的了解" class="headerlink" title="6. 谈谈自己对于 AOP 的了解"></a>6. 谈谈自己对于 AOP 的了解</h4><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理</p>
<h4 id="7-Spring-事务中的隔离级别有哪几种"><a href="#7-Spring-事务中的隔离级别有哪几种" class="headerlink" title="7. Spring 事务中的隔离级别有哪几种?"></a>7. Spring 事务中的隔离级别有哪几种?</h4><p>下面我依次对每一种事务隔离级别进行介绍：</p>
<ul>
<li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :使用数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :未提交读。最低的隔离级别，未提交事务其他的事务也能读取，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : 提交读。事务提交了才能被其他事务读取，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : 可重复读。保证多次读取同一个数值时，读之前和读之后是一致的，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h4 id="8-Spring的优缺点"><a href="#8-Spring的优缺点" class="headerlink" title="8. Spring的优缺点"></a>8. Spring的优缺点</h4><p>优点：</p>
<ul>
<li>IOC将对象之间的依赖关系交给Spring，降低组件之间的耦合，实现各个层之间的解耦，让我们更加专注于业务逻辑。</li>
<li>提高面向切面编程。</li>
<li>对各种主流插件提供了很好的集成支持。</li>
<li>对事务支持的比较好，只要配置即可，无须手动控制。</li>
</ul>
<p>缺点：</p>
<ul>
<li>依赖反射，影响性能，</li>
</ul>
<h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><h4 id="1-mybatis中-和-的区别是什么？"><a href="#1-mybatis中-和-的区别是什么？" class="headerlink" title="1. mybatis中#{}和${}的区别是什么？"></a>1. mybatis中#{}和${}的区别是什么？</h4><ul>
<li>#{}是预编译，${}是字符替换。</li>
<li>在使用#{}时，mybatis会将sql中的#{}替换成?，配合PreparedStatement的set方法赋值，这样可以有效的防止sql注入，保证程序的运行安全。</li>
</ul>
<h4 id="2-说下mybatis的一级缓存和二级缓存？"><a href="#2-说下mybatis的一级缓存和二级缓存？" class="headerlink" title="2. 说下mybatis的一级缓存和二级缓存？"></a>2. 说下mybatis的一级缓存和二级缓存？</h4><ul>
<li>一级缓存：基于sqlSession级别的HashMap本地缓存，它的声明周期和sqlSession一致的。默认一级缓存是开启的。sqlSession对数据库一个操作会缓存起来，再次进行同样的操作的时候就会读取缓存。但也不是每次都读取一级缓存中的内容，比如：一级缓存被清除了或者不是同一个数据或进行了增删改的操作</li>
<li>二级缓存：基于namespace级别的缓存。如果多个sqlSession之间需要共享缓存，则需要用到二级缓存。当sqlSession提交或者关闭，就会把缓存放到二级缓存中。</li>
</ul>
<p>开启二级缓存后数据的查询流程是：二级缓存-&gt;一级缓存-&gt;数据库</p>
<h4 id="3-说下Mybatis的优缺点"><a href="#3-说下Mybatis的优缺点" class="headerlink" title="3. 说下Mybatis的优缺点"></a>3. 说下Mybatis的优缺点</h4><p>优点：</p>
<ul>
<li>解除了sql和程序的耦合</li>
<li>比jdbc，基本上配置好了，大部分的工作量就专注于sql部分</li>
<li>方便维护管理，sql不需要在Java代码上找，sql代码可以分离出来，重用</li>
<li>接近jdbc，灵活，支持动态sql</li>
</ul>
<p>缺点：</p>
<ul>
<li>移植性差。sql语法依赖数据库，不同数据库的切换会因为语法差异报错</li>
<li>SQL语句的编写工作量比较大，尤其是字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求</li>
</ul>
<h4 id="4-Mybatis中9个动态标签是？"><a href="#4-Mybatis中9个动态标签是？" class="headerlink" title="4. Mybatis中9个动态标签是？"></a>4. Mybatis中9个动态标签是？</h4><ul>
<li>if</li>
<li>choose</li>
<li>trim</li>
<li>foreach</li>
<li>bind</li>
</ul>
<h4 id="5-Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#5-Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="5. Mybatis是如何进行分页的？分页插件的原理是什么？"></a>5. Mybatis是如何进行分页的？分页插件的原理是什么？</h4><ol>
<li><p>Mybatis使用RowBounds对象进行分页的，也可以直接编写sql实现分页，也可以使用Mybatis的分页插件比如PageHelper。</p>
</li>
<li><p>分页插件的原理：实现Mybatis提供的接口，实现自定义插件，在插件的拦截方法内拦截执行的sql，然后重写sql</p>
<p>举例：select from student，拦截sql后重写为：select t.from (select from student) t limit 0,10</p>
</li>
</ol>
<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><h4 id="1-SpringBoot有什么优点？我们为什么要用它？"><a href="#1-SpringBoot有什么优点？我们为什么要用它？" class="headerlink" title="1. SpringBoot有什么优点？我们为什么要用它？"></a>1. SpringBoot有什么优点？我们为什么要用它？</h4><p>SpringBoot实现了自动化配置，简化了配置，让我们使用更加简单快捷</p>
<h4 id="2-SpringBoot核心注解？"><a href="#2-SpringBoot核心注解？" class="headerlink" title="2. SpringBoot核心注解？"></a>2. SpringBoot核心注解？</h4><p>SpringBoot的核心注解是SpringBootApplication，其主要组合包括以下注解：</p>
<ol>
<li>@SpringBootConfiguration:  组合了@Configuration注解，实现了配置文件功能</li>
<li>@ComponentScanner:	  Spring组建扫描</li>
<li>@EnableAutoConfiguration：打开了自动配置</li>
</ol>
<h4 id="3-SpringBoot自动配置原理？"><a href="#3-SpringBoot自动配置原理？" class="headerlink" title="3. SpringBoot自动配置原理？"></a>3. SpringBoot自动配置原理？</h4><p>Spring Boot启动的时候会通过@EnableAutoConfiguration注解找到META-INF&#x2F;spring.factories配置文件中的所有配置类，并对其进行加载，而这些自动配置类都是以AutoConfiguration结尾来命名的，它实际上就是一个JavaConfig形式的Spring容器配置类，它能通过Properties结尾命名的类中通过@ConfigurationPropertis注解和配置文件中对应的属性进行绑定的。</p>
<h4 id="4-SpringBoot读取配置文件的方式？"><a href="#4-SpringBoot读取配置文件的方式？" class="headerlink" title="4. SpringBoot读取配置文件的方式？"></a>4. SpringBoot读取配置文件的方式？</h4><ol>
<li>@Value </li>
<li>@ConfigurationProperties +@Component </li>
<li>@Configuration+@EnableConfigurationProperties</li>
</ol>
<h3 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h3><h4 id="1-什么是Spring-Cloud？"><a href="#1-什么是Spring-Cloud？" class="headerlink" title="1. 什么是Spring Cloud？"></a>1. 什么是Spring Cloud？</h4><p>Spring Cloud就是微服务系统架构的一站式解决方案，在平时构建微服务的过程中需要做到如<strong>服务发现</strong>、<strong>配置中心</strong>、<strong>消息总线</strong>、<strong>负载均衡</strong>、<strong>断路器</strong>、<strong>数据监控</strong>等操作。而Spring Cloud为我们提供了一套简易的编程模型，使我们能在Spring Boot的基础上轻松地实现微服务项目的构建。</p>
<h4 id="2-Nginx-和-Ribbon-的对比"><a href="#2-Nginx-和-Ribbon-的对比" class="headerlink" title="2.  Nginx 和 Ribbon 的对比"></a>2.  Nginx 和 Ribbon 的对比</h4><ul>
<li>Nginx是一种集中式的负载均衡器：将所有的请求都集中起来，然后在进行负载均衡。</li>
<li>Ribbon是先进行请求的负载均衡才发出请求的。</li>
</ul>
<h4 id="3-Ribbon-的几种负载均衡算法？"><a href="#3-Ribbon-的几种负载均衡算法？" class="headerlink" title="3. Ribbon 的几种负载均衡算法？"></a>3. Ribbon 的几种负载均衡算法？</h4><p>负载均衡，不管 <code>Nginx</code> 还是 <code>Ribbon</code> 都需要其算法的支持，如果我没记错的话 <code>Nginx</code> 使用的是 轮询和加权轮询算法。而在 <code>Ribbon</code> 中有更多的负载均衡调度算法，其默认是使用的 <code>RoundRobinRule</code> 轮询策略。</p>
<ul>
<li>**<code>RoundRobinRule</code>**：轮询策略。<code>Ribbon</code> 默认采用的策略。若经过一轮轮询没有找到可用的 <code>provider</code>，其最多轮询 10 轮。若最终还没有找到，则返回 <code>null</code>。</li>
<li><strong><code>RandomRule</code></strong>: 随机策略，从所有可用的 <code>provider</code> 中随机选择一个。</li>
<li><strong><code>RetryRule</code></strong>: 重试策略。先按照 <code>RoundRobinRule</code> 策略获取 <code>provider</code>，若获取失败，则在指定的时限内重试。默认的时限为 500 毫秒。</li>
</ul>
<h4 id="4-Spring-Cloud的核心组件有哪些？"><a href="#4-Spring-Cloud的核心组件有哪些？" class="headerlink" title="4. Spring Cloud的核心组件有哪些？"></a>4. Spring Cloud的核心组件有哪些？</h4><ul>
<li><p>Eureka：服务注册与发现</p>
</li>
<li><p>Feign：基于动态代理机制，根据注解和选择的机器，拼接请求url地址，发起请求</p>
</li>
<li><p>Ribbon：实现负载均衡，从一个服务的多台机器中选择一台</p>
</li>
<li><p>Hystrix：实现了分布式系统的熔断和降级</p>
</li>
<li><p>Zuul：网关管理，由Zuul网关转发请求给对应的服务</p>
</li>
<li><p>Config：微服务统一配置中心</p>
</li>
<li><p>Bus：消息总线</p>
</li>
</ul>
<h4 id="5-什么是-Hystrix-之熔断和降级？"><a href="#5-什么是-Hystrix-之熔断和降级？" class="headerlink" title="5. 什么是 Hystrix 之熔断和降级？"></a>5. 什么是 Hystrix 之熔断和降级？</h4><ul>
<li>熔断：当指定时间窗内的请求失败率达到了设定的阈值的时候，系统将通过断路器直接将请求链路给断开。</li>
<li>降级：是为了更好的用户体验，当一个方法调用异常时，通过执行另一种代码逻辑来给用户更友好的回复。</li>
</ul>
<h4 id="6-什么是配置中心？"><a href="#6-什么是配置中心？" class="headerlink" title="6. 什么是配置中心？"></a>6. 什么是配置中心？</h4><p>配置中心能将各个应用&#x2F;系统&#x2F;模块的配置文件存放到统一的地方进行管理。</p>
<h4 id="7-Zookeeper和Eureka的区别？"><a href="#7-Zookeeper和Eureka的区别？" class="headerlink" title="7. Zookeeper和Eureka的区别？"></a>7. Zookeeper和Eureka的区别？</h4><blockquote>
<ol>
<li>什么是CAP原则？</li>
</ol>
</blockquote>
<img src="https://cdn.nlark.com/yuque/0/2022/png/3003862/1649232795540-336b7a30-7fa2-4983-8b6a-7b77646bdb39.png" srcset="/img/loading.gif" lazyload alt="img" style="zoom:67%;">

<p>指的是在一个分布式系统中，<strong>Consistency（一致性）</strong>、 <strong>Availability（可用性）</strong>、<strong>Partition tolerance（分区容错性）</strong>，三者不可兼得（我们常说的鱼和熊掌不可兼得）。CAP 原则也是 NoSQL 数据库的基石。</p>
<blockquote>
<ol start="2">
<li>CAP原则的三个指标</li>
</ol>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/3003862/1649232917219-784c7da0-9aea-4381-a80e-0d6a01e00193.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>1、<strong>一致性（Consistency，C）</strong>：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）。</p>
<p><strong>2、可用性（Availability，A）</strong>：在一个分布式系统的集群中一部分节点故障后，该集群是否还能够正常响应客户端的读写请求。（每次请求都能获取到非错的响应，但不能保证获取的数据为最新数据）。</p>
<p><strong>3、分区容错性（Partition tolerance，P）：</strong>大多数的分布式系统都分布在多个子网络中，而每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如阿里巴巴的服务器（不知道各位有没有发现，不管你到那个城市去，你访问的服务器总是该城市的，其中使用 了算法，由于篇幅有限就不再这儿一一讲解了），一台服务器放在上海，另一台服务器放在北京，这就是两个区，它们之间可能存在无法通信的情况。（尽管任意数量的消息被节点间的网络丢失或延迟，系统仍然正常运行）</p>
<p>在一个分布式系统中一般分区容错是无法避免的，因此可以认为 CAP 中的 P 总是成立的。CAP 理论告诉我们，在 C 和 A 之间是无法同时做到。</p>
<ol>
<li>CAP原则的理解</li>
</ol>
<ul>
<li><p>CAP理论的C 不等于 事务ACID特性中的C</p>
</li>
<li><p>我们可以把CAP理论中的C理解为<strong>副本的一致性</strong>。即所有副本给出的结果都一致。</p>
</li>
<li><p>在没有网络波动和网络分区的情况下，我们无需为了P而舍弃C或者A；而出现网络分区或者网络波动时，为了保证P，就要舍弃C和A中的一个。</p>
</li>
<li><p>假设有三个副本</p>
</li>
<li><ul>
<li>\1. W&#x3D;1，一写，向三个副本写入，但一个副本返回写入成功即为成功。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/3003862/1649234464843-784b3861-5e46-415a-9177-9ad6119c9a01.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>一写的情况下，只要一个副本写入成功即可返回写入成功。出现网络分区后，三台机器的数据就可能出现不一致，无法保证C；但因为可以正常返回写入成功，A依旧可以保证。</p>
<ul>
<li><ul>
<li>\2. W&#x3D;3，三写，向三个副本写入，三个副本都返回写入成功才认为成功</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/3003862/1649234676561-8b951125-b650-4cf4-8895-ea8ef62028e5.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>在三写的情况下，要三个副本都写入成功才可返回成功，出现网络分区后，无法实现这点，最终会返回报错，所以没有保证A，但保证了C。</p>
<ol start="2">
<li>用CAP理论分析分布式数据库</li>
</ol>
<ul>
<li><strong>在分布式环境下，P是一定存在的，一旦出现了网络分区，那么一致性和可用性就一定要抛弃一个。</strong></li>
<li>对于NoSQL数据库，更加注重可用性，所以就会是一个AP系统。</li>
<li>对于分布式关系型数据库，必须要保证一致性，所以就会是一个CP系统。</li>
</ul>
<p>zookeeper和eureka的区别</p>
<ul>
<li>zookeeper是CP，而eureka是AP</li>
</ul>
<h2 id="数据库篇"><a href="#数据库篇" class="headerlink" title="数据库篇"></a>数据库篇</h2><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><h4 id="1-内连接、左连接、右连接有什么区别？"><a href="#1-内连接、左连接、右连接有什么区别？" class="headerlink" title="1. 内连接、左连接、右连接有什么区别？"></a>1. 内连接、左连接、右连接有什么区别？</h4><p>内连接：inner join  左连接：left join  右连接：right join</p>
<p>内连接是两个表关联匹配的信息显示出来，左连接是左边表全部，和另一个表匹配信息显示出来。</p>
<p>右连接相反。</p>
<h4 id="2-truncate和delete有什么区别？"><a href="#2-truncate和delete有什么区别？" class="headerlink" title="2. truncate和delete有什么区别？"></a>2. truncate和delete有什么区别？</h4><ol>
<li>delete可以加where，truncate不能</li>
<li>truncate删除的效率更高</li>
<li>加入要删除的表中有自增长列，那么delete删除了之后是从上一条数据的下一个开始，而truncate是从1开始的</li>
<li>delete没有返回值，而truncate有返回值</li>
<li>truncate删除了不能回滚，而delete删除了可以回滚</li>
</ol>
<h4 id="3-char和varchar有什么区别？"><a href="#3-char和varchar有什么区别？" class="headerlink" title="3. char和varchar有什么区别？"></a>3. char和varchar有什么区别？</h4><ol>
<li>char是固定长度的，而varchar是可变长度的。（比如加入abc，char中存入3个字节，有7个是空的）</li>
<li>char的效率稍高</li>
</ol>
<h4 id="4-float和double有什么区别？"><a href="#4-float和double有什么区别？" class="headerlink" title="4. float和double有什么区别？"></a>4. float和double有什么区别？</h4><p>float：最多可以存储8位的十进制数,在内存中占4个字节</p>
<p>double：最多可以存储16位的十进制,在内存中占8个字节</p>
<h4 id="5-说下ACID是什么？"><a href="#5-说下ACID是什么？" class="headerlink" title="5. 说下ACID是什么？"></a>5. 说下ACID是什么？</h4><ul>
<li>Atomicity(原子性)：一个事务中的所有操作，要么全部都执行，要不都不执行。事务中的某个操作有误，可以进行回滚操作。</li>
<li>Consistency(一致性)：在事务开始和结束前后，数据库的完整性没被破坏</li>
<li>Isolation（隔离性）：数据库允许多个并发事务对数据库进行读写操作，隔离性可以防止多个事务并发修改数据时而导致数据的不一致。事务隔离包括分为不同级别，包括读未提交、读提交、可重复读和串行化。</li>
<li>Durability（持久性）：事务处理结束后，对数据的修改就是永久的</li>
</ul>
<h4 id="6-数据库的三范式是什么？"><a href="#6-数据库的三范式是什么？" class="headerlink" title="6. 数据库的三范式是什么？"></a>6. 数据库的三范式是什么？</h4><p>第一范式：强调的是列的原子性。</p>
<p>第二范式：要求实体的属性完全依赖于主关键字。</p>
<p>第三范式：任何非主属性不依赖于其他非主属性。</p>
<h4 id="7-索引有哪些？"><a href="#7-索引有哪些？" class="headerlink" title="7. 索引有哪些？"></a>7. 索引有哪些？</h4><ol>
<li>主键索引 2.普通索引 3. 唯一索引 4. 复合索引。</li>
</ol>
<h4 id="8-说说三大日志吧"><a href="#8-说说三大日志吧" class="headerlink" title="8. 说说三大日志吧"></a>8. 说说三大日志吧</h4><ol>
<li>redolog：保证了事务的持久性（只要对事务提交成功，则对数据库的修改就永久保存起来）</li>
<li>undolog：保证了事务的原子性，每次事务开始之前，先将原数据备份到undolog中，对数据进行修改出现异常，可以利用undolog中的数据进行恢复</li>
<li>binlog：记录了所有Mysql的写入数据库的操作</li>
</ol>
<h4 id="9-innodb是如何实现事务的四大特性的？"><a href="#9-innodb是如何实现事务的四大特性的？" class="headerlink" title="9. innodb是如何实现事务的四大特性的？"></a>9. innodb是如何实现事务的四大特性的？</h4><ol>
<li><p>原子性：由undolog进行实现的，每次事务开始前会将原数据备份到undolog中，一旦事务执行失败则可以利用undolog进行恢复</p>
</li>
<li><p>隔离性：隔离性可能会引入脏读、不可重复读、幻读等问题，为了解决这些问题就引入了隔离级别的概念。读未提交：一个事务还没提交，它做的变更就能被别的事务看到。读提交：一个事务提交之后，它做的变更。可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的一致。利用锁和MVCC机制。MVCC时多版本并发控制，在读提交、可重复读这两个隔离级别的事务下，每条记录在更新的时候都会同时记录一条回滚操作，就会形成一个版本链，在执行普通的SELECT操作时访问记录的版本链的过程，这样可以使不同事务的读-写、写-读操作并非执行，提高系统性能。</p>
</li>
<li><p>持久性：由redolog实现，每次事务的提交都会持久化地存储到redolog中</p>
</li>
<li><p>一致性：一般是我们写的业务代码来保证的。</p>
</li>
</ol>
<h4 id="10-innodb为什么要用B-tree？"><a href="#10-innodb为什么要用B-tree？" class="headerlink" title="10. innodb为什么要用B+tree？"></a>10. innodb为什么要用B+tree？</h4><ol>
<li><p>IO操作次数少：只要叶子节点保存了数据，其他节点保存了索引，所以内部结构就更小。</p>
</li>
<li><p>每次查都是一页的数据放入内存，当查到同一页中的数据时，就可以直接读出来。</p>
</li>
</ol>
<h4 id="11-说下乐观锁和悲观锁？"><a href="#11-说下乐观锁和悲观锁？" class="headerlink" title="11. 说下乐观锁和悲观锁？"></a>11. 说下乐观锁和悲观锁？</h4><ul>
<li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据</li>
<li>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿到这个数据就会去阻止，直到锁被释放</li>
</ul>
<p>数据库的乐观锁需要自己实现，在表里面添加一个version字段，每次修改成功值加1，这样每次修改的时候先对比一下，自己拥有的version和数据库现在的version是否一致，如果不一致就不修改，这样就实现了乐观锁。</p>
<h4 id="12-什么是聚簇索引、非聚簇索引？"><a href="#12-什么是聚簇索引、非聚簇索引？" class="headerlink" title="12. 什么是聚簇索引、非聚簇索引？"></a>12. 什么是聚簇索引、非聚簇索引？</h4><ul>
<li><p><strong>聚簇索引：将数据和索引一起存储，叶子节点存储了行数据。</strong></p>
</li>
<li><p><strong>非聚簇索引：将数据和索引分开存储，索引结构的叶子节点指向了数据对应的位置</strong></p>
</li>
</ul>
<h4 id="13-聚簇索引的优势在哪？"><a href="#13-聚簇索引的优势在哪？" class="headerlink" title="13. 聚簇索引的优势在哪？"></a>13. 聚簇索引的优势在哪？</h4><ul>
<li><p>由于行数据和聚簇索引的叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中（缓存器），再次访问时，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。</p>
</li>
<li><p>辅助索引的叶子节点，存储主键值，而不是数据的存放地址。好处是当行数据放生变化时，索引树的节点也需要分裂变化；或者是我们需要查找的数据，在上一次IO读写的缓存中没有，需要发生一次新的IO操作时，可以避免对辅助索引的维护工作，只需要维护聚簇索引树就好了。另一个好处是，因为辅助索引存放的是主键值，减少了辅助索引占用的存储空间大小。</p>
</li>
</ul>
<h4 id="14-什么情况下无法利用索引呢"><a href="#14-什么情况下无法利用索引呢" class="headerlink" title="14. 什么情况下无法利用索引呢?"></a>14. 什么情况下无法利用索引呢?</h4><ul>
<li><p>查询语句中使用LIKE关键字：在查询语句中使用 LIKE 关键字进行查询时，如果匹配字符串的第一个字符为“%”，索引不会被使用。如果“%”不是在第一个位置，索引就会被使用。</p>
</li>
<li><p>查询语句中使用多列索引：多列索引是在表的多个字段上创建一个索引，只有查询条件中使用了这些字段中的第一个字段，索引才会被使用。</p>
</li>
<li><p>查询语句中使用OR关键字：查询语句只有OR关键字时，如果OR前后的两个条件的列都是索引，那么查询中将使用索引。如果OR前后有一个条件的列不是索引，那么查询中将不使用索引。</p>
</li>
<li><p>使用不等于</p>
</li>
</ul>
<h4 id="15-索引的优劣势"><a href="#15-索引的优劣势" class="headerlink" title="15. 索引的优劣势"></a>15. 索引的优劣势</h4><p>优势：</p>
<ol>
<li>类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li>
</ol>
<p>劣势：</p>
<ol>
<li>实际上索引也是一张表，该表中保存了主键和索引字段，并指向实体类的记录，所以索引列也是要占有空间的。</li>
<li>虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，Mysql不仅要保存数据，还有保存一下索引文件每次更新了索引列的字段，都会调整因为更新带来的键值变化后的索引信息。</li>
</ol>
<h4 id="16-innodb和myisam的区别"><a href="#16-innodb和myisam的区别" class="headerlink" title="16. innodb和myisam的区别"></a>16. innodb和myisam的区别</h4><ul>
<li><p>innodb支持事务，而myisam不支持事务</p>
</li>
<li><p>innodb支持外键，而myisam不支持外键</p>
</li>
<li><p>innodb默认表锁，使用索引检索条件是行锁，而myisam是表锁（每次更新增加删除都会锁住表）</p>
</li>
<li><p>innodb和myisam的索引都是基于b+树，但他们的具体实现不同，innodb的b+树的叶子节点是存放数据的，myisam的b+树的叶子节点是存放指针的</p>
</li>
<li><p>innodb是聚簇索引，myisam是非聚簇索引</p>
<p>总结：mysql默认使用innodb，如果要用事务和外键就使用innodb，如果这张表只用来查询，可以用myisam，如果增删改查频繁就使用innodb</p>
</li>
</ul>
<h4 id="17-表的设计理解"><a href="#17-表的设计理解" class="headerlink" title="17. 表的设计理解"></a>17. 表的设计理解</h4><blockquote>
<p>不建立外键</p>
</blockquote>
<ol>
<li><p>数据库需要维护外键的内部管理；</p>
</li>
<li><p>外键等于把数据的一致性事务实现，全部交给数据库服务器完成；</p>
</li>
<li><p>有了外键，当做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，而不得不消耗资源；</p>
</li>
<li><p>外键还会因为需要请求对其他表内部加锁而容易出现死锁情况；</p>
</li>
</ol>
<blockquote>
<p>尽力使用内存容量小的数据结构</p>
</blockquote>
<p>mysql一页是 16K 这16k里你的数据越多,查询时IO操作耗时越久</p>
<p>字段类型的优先级：</p>
<ol>
<li>数字类型</li>
<li>日期类型与二进制</li>
<li>字符串类型</li>
</ol>
<blockquote>
<p>各数据类型介绍</p>
</blockquote>
<img src="/2022/05/01/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BD%92%E7%BA%B3/image-20220524223851156.png" srcset="/img/loading.gif" lazyload alt="image-20220524223851156" style="zoom:67%;">

<img src="/2022/05/01/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BD%92%E7%BA%B3/image-20220524223912311.png" srcset="/img/loading.gif" lazyload alt="image-20220524223912311" style="zoom:67%;">



<p>varchar类型：是一种可变长度的数据类型。</p>
<p>主要的适用场景有：</p>
<ol>
<li>varchar适合存储长度波动大的数据（如博客文章）</li>
<li>字符串很少被更新的场景 </li>
<li>varchar适合保存多字节字符</li>
</ol>
<p>char类型：属于定长数据</p>
<ol>
<li>char最长长度为255</li>
<li>char类型会自动删除末尾的空格</li>
<li>char检索效率比varchar高</li>
</ol>
<p>主要使用场景有：</p>
<ul>
<li>char适合存储长度波动不大的数据，如MD5摘要</li>
<li>char适合存储短字符串</li>
<li>char类型适合存储经常更新的字符串</li>
</ul>
<p>datetime日志类型：日期时间类型，占有8个字节</p>
<ul>
<li>与时区无关</li>
<li>可保存到毫秒</li>
<li>可保存的时间范围更大</li>
<li>不要使用字符串来存储日期类型</li>
</ul>
<p>timestamp日志类型：时间戳，占有4个字节</p>
<ul>
<li>时间范围：1970-01-01到2038-01-19</li>
<li>精确到秒</li>
<li>采用整型存储</li>
<li>依赖与时区</li>
<li>自动更新timestamp列的值</li>
</ul>
<h4 id="18-SQL优化"><a href="#18-SQL优化" class="headerlink" title="18. SQL优化"></a>18. SQL优化</h4><blockquote>
<p>优化 select 语句</p>
</blockquote>
<ol>
<li>明知只有一条查询结果，那请使用 “LIMIT 1”  这样就会在检索出第一条符合条件的数据后不继续向下检索，效率会快很多</li>
<li>不要使用select * </li>
<li>避免在where中判断null和不等于、or、in（可能会出现全表扫描）</li>
<li>尽力使用inner join 避免使用left join</li>
</ol>
<blockquote>
<p>优化insert语句</p>
</blockquote>
<p>当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。</p>
<p>如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。</p>
<img src="/2022/05/01/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BD%92%E7%BA%B3/image-20220524230508039.png" srcset="/img/loading.gif" lazyload alt="image-20220524230508039" style="zoom:67%;">



<blockquote>
<p>优化排序</p>
</blockquote>
<p>了解了MySQL的排序方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据。where 条件和Order by 使用相同的索引，并且Order By 的顺序和索引顺序相同， 并且Order by 的字段都是升序，或者都是降序。否则肯定需要额外的操作，这样就会出现FileSort。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 不走age索引</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age;<br> <br><span class="hljs-comment">-- 走age索引</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>优化分组</p>
</blockquote>
<p>由于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。所以，在GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。</p>
<p>如果查询包含 group by 但是用户想要避免排序结果的消耗， 则<strong>可以执行order by null 禁止排序</strong>。如下 ：</p>
<p>Mysql4.1版本之后，开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代</p>
<blockquote>
<p>建议使用 union 替换 or 或者 in代替or</p>
</blockquote>
<p>UNION 语句的 type 值为 ref，OR 语句的 type 值为 range，可以看到这是一个很明显的差距</p>
<p>UNION 语句的 ref 值为 const，OR 语句的 type 值为 null，const 表示是常量值引用，非常快</p>
<p>这两项的差距就说明了 UNION 要优于 OR 。 </p>
<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><h4 id="1-redis本身有持久化，为什么还要写进mysql呢"><a href="#1-redis本身有持久化，为什么还要写进mysql呢" class="headerlink" title="1. redis本身有持久化，为什么还要写进mysql呢?"></a>1. redis本身有持久化，为什么还要写进mysql呢?</h4><ul>
<li>RDB：快照形式是直接把内存中的数据保存到一个dump文件中，定时保存，保存策略。</li>
<li>AOF：把所有的对Redis的服务器进行修改的命令都保存一个文件中，命令的集合。</li>
<li>RDB会丢失数据、AOP性能不好。</li>
<li>有改动先插入到数据库，再插入缓存，比较靠谱但性能一般。</li>
<li>有改动先插入缓存，批量更新到数据库，靠谱度略差，但性能好。</li>
</ul>
<h4 id="2-redis的数据结构"><a href="#2-redis的数据结构" class="headerlink" title="2. redis的数据结构"></a>2. redis的数据结构</h4><ol>
<li>Redis有5个基本的数据结构：string、list、hash、set和zset</li>
<li>String ：string表示的是一个可变的字节数组，我们可以初始化字符串的内容、可以拿到字符串的长度，可以获取string的子串，可以覆盖string的子串，可以追加子串。</li>
<li>list ：底层是双向链表</li>
<li>hash：等价于HashMap</li>
<li>set：底层也是HashMap</li>
<li>zset：类似于TreeSet给每个元素的value赋予一个权重score，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</li>
</ol>
<h4 id="3-为什么要用Redis而不用map-guava做缓存？"><a href="#3-为什么要用Redis而不用map-guava做缓存？" class="headerlink" title="3. 为什么要用Redis而不用map&#x2F;guava做缓存？"></a>3. 为什么要用Redis而不用map&#x2F;guava做缓存？</h4><p>本地缓存虽然轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每个实例都需各自保存一份缓存，缓存不具有一致性。而redis是属于分布式缓存，在多个实例的情况下，各实例共用一份缓存数据，缓存具有一致性。</p>
<h4 id="4-为什么redis怎么快？"><a href="#4-为什么redis怎么快？" class="headerlink" title="4. 为什么redis怎么快？"></a>4. 为什么redis怎么快？</h4><ul>
<li>完全基于内存。</li>
<li>数据结构简单，对数据操作简单。</li>
<li>采用单线程，避免了不必要的上下文切换。</li>
</ul>
<h4 id="5-Redis的持久化机制是什么？各自的优点是什么？"><a href="#5-Redis的持久化机制是什么？各自的优点是什么？" class="headerlink" title="5. Redis的持久化机制是什么？各自的优点是什么？"></a>5. Redis的持久化机制是什么？各自的优点是什么？</h4><ul>
<li><p>redis有两种持久化机制：1. RDB（默认） 2. AOF</p>
</li>
<li><p>RDB是redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p>
</li>
<li><p>AOF持久化，则是将redis执行的每次写命令记录到单独的日志文件中，当重启redis会重新将持久化的日志文件中恢复数据。</p>
</li>
<li><p>RDB优点：</p>
</li>
<li><ul>
<li>只有一个文件dump.rdb,方便持久化。</li>
<li>性能更好。fork子进程来完成写操作，让主进程继续处理命令，所以IO最大化。</li>
<li>相对于数据集大时，比AOF的启动效率更高。</li>
</ul>
</li>
<li><p>RDB缺点：</p>
</li>
<li><ul>
<li>数据安全性低：RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。</li>
</ul>
</li>
</ul>
<h4 id="6-缓存雪崩"><a href="#6-缓存雪崩" class="headerlink" title="6. 缓存雪崩"></a>6. 缓存雪崩</h4><ul>
<li><p>定义：在高并发下，大量缓存key在同一时间失效，大量请求直接落到数据库上，导致数据库宕机。</p>
</li>
<li><p>解决方案：</p>
</li>
<li><ul>
<li>随机设置key失效时间，避免同一时间大量key集体失效。</li>
<li>若是集群部署，可将热点数据均匀分布到不同的redis库中。</li>
<li>不设置过期时间</li>
<li>跑定时任务，在缓存失效前刷进新内存。</li>
</ul>
</li>
</ul>
<h4 id="7-缓存穿透"><a href="#7-缓存穿透" class="headerlink" title="7. 缓存穿透"></a>7. 缓存穿透</h4><ul>
<li><p>缓存穿透是指缓存和数据库中都没有的数据，导致所有请求都落到数据库上，造成数据短时间内承受大量请求而崩掉。</p>
</li>
<li><p>解决方案：</p>
</li>
<li><ul>
<li>对参数进行校验，不合法参数进行拦截</li>
<li>拉黑ip</li>
<li>从缓存中取不到的数据，在数据库中也没有取得，这时也可以将key-value对写为key-null。并对其设置较短的过期时间。</li>
</ul>
</li>
</ul>
<h4 id="8-缓存击穿"><a href="#8-缓存击穿" class="headerlink" title="8. 缓存击穿"></a>8. 缓存击穿</h4><ul>
<li><p>缓存中没有但是数据库有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又去数据库中取取数据，引起数据库压力瞬间增大，造成了过大的压力。和缓存雪崩不同是，缓存击穿是指并发查同一条数据，缓存雪崩时不同数据都过期了，很多数据库查不到从而查数据库。</p>
</li>
<li><p>解决方案：</p>
</li>
<li><ul>
<li>设置热点数据永远不过期</li>
<li>接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些 服务 不可用时候，进行熔断，失败快速返回机制。</li>
<li>加互斥锁</li>
</ul>
</li>
</ul>
<h4 id="9-说一说redis的数据过期淘汰策略"><a href="#9-说一说redis的数据过期淘汰策略" class="headerlink" title="9. 说一说redis的数据过期淘汰策略"></a>9. 说一说redis的数据过期淘汰策略</h4><ul>
<li>redis中数据测量采用定期删除+惰性删除测量</li>
<li>定期删除策略：redis启用一个定时器定时监视所有的key，判断key是否过期，过期的话就删除。</li>
<li>惰性删除策略：在获取key的时候，先判断key是否过期，如果过期则删除。</li>
</ul>
<h4 id="10-redis是什么？都有哪些使用的场景？"><a href="#10-redis是什么？都有哪些使用的场景？" class="headerlink" title="10. redis是什么？都有哪些使用的场景？"></a>10. redis是什么？都有哪些使用的场景？</h4><p>redis是一个使用C语言开发的高速缓存数据库。</p>
<p>redis使用场景：</p>
<ul>
<li>记录帖子的点赞数、点击数、评价数</li>
<li>缓存近期热贴</li>
<li>缓存文章详情信息</li>
<li>记录用户会话信息</li>
</ul>
<h4 id="11-怎么保证缓存和数据库数据的一致性"><a href="#11-怎么保证缓存和数据库数据的一致性" class="headerlink" title="11. 怎么保证缓存和数据库数据的一致性"></a>11. 怎么保证缓存和数据库数据的一致性</h4><ul>
<li>合理设置缓存的过期时间</li>
<li>新增、更改、删除数据库操作时同步更新redis，可以使用事务机制来保证数据的一致性</li>
</ul>
<h4 id="12-redis的主要应用"><a href="#12-redis的主要应用" class="headerlink" title="12. redis的主要应用"></a>12. redis的主要应用</h4><ul>
<li>缓存</li>
<li>排行榜</li>
<li>计数器</li>
<li>分布式会话</li>
<li>分布式锁</li>
<li>社交网络</li>
<li>最新列表</li>
<li>消息系统</li>
</ul>
<h4 id="13-RDB的持久化是如何触发的？"><a href="#13-RDB的持久化是如何触发的？" class="headerlink" title="13. RDB的持久化是如何触发的？"></a>13. RDB的持久化是如何触发的？</h4><p>手动触发：</p>
<ul>
<li>save：阻塞当前Redis服务器，直到RDB过程完成为止，如果数据比较大，会造成长时间的阻塞（线上不建议）</li>
<li>bgsave：redis进程fork操作创建子进程，持久化由子进程负责，完成后自动结束，阻塞只发生在fork阶段，一半时间很短</li>
</ul>
<p>自动触发：</p>
<ul>
<li>save xseconds n：表示在x秒内，至少有n个键发生变化，就会触发RDB持久化，也就是说满足了条件就会触发持久化</li>
<li>flushall：主从同步触发</li>
</ul>
<h4 id="14-什么是缓存预热？"><a href="#14-什么是缓存预热？" class="headerlink" title="14. 什么是缓存预热？"></a>14. 什么是缓存预热？</h4><p>就是系统上线后提前将相关数据加载到缓存系统中，避免用户查库，然后在缓存。</p>
<h2 id="JVM篇"><a href="#JVM篇" class="headerlink" title="JVM篇"></a>JVM篇</h2><h3 id="1-说说类加载过程？"><a href="#1-说说类加载过程？" class="headerlink" title="1. 说说类加载过程？"></a>1. 说说类加载过程？</h3><blockquote>
<p>加载阶段</p>
</blockquote>
<p>根据类的全名获取类的二进制数据流并创建Class类的实例</p>
<blockquote>
<p>链接</p>
</blockquote>
<ol>
<li><p>验证：</p>
<p>验证加载的字节码是合法的、合理并符合规范</p>
</li>
<li><p>准备：</p>
</li>
</ol>
<p>​		为静态变量分配内存，并初始化默认值</p>
<ol start="3">
<li>解析：</li>
</ol>
<p>​		将类、方法、接口等从符号引用转化为直接引用</p>
<blockquote>
<p>初始化</p>
</blockquote>
<p>为类的静态变量赋初始值</p>
<h3 id="2-什么是类加载器？常见的类加载器有哪些？"><a href="#2-什么是类加载器？常见的类加载器有哪些？" class="headerlink" title="2. 什么是类加载器？常见的类加载器有哪些？"></a>2. 什么是类加载器？常见的类加载器有哪些？</h3><p>类加载器是指根据类的全限类名获取到该类的二进制字节流。类的加载器有4种：</p>
<ol>
<li>启动类加载器：主要是加载java的核心内库</li>
<li>扩展类加载器：主要是加载java的拓展内库</li>
<li>应用程序类加载器：大部分的应用类都是由这个加载</li>
<li>自定义类加载器</li>
</ol>
<h3 id="3-什么是双亲委派机制？为什么需要双亲委派机制？"><a href="#3-什么是双亲委派机制？为什么需要双亲委派机制？" class="headerlink" title="3. 什么是双亲委派机制？为什么需要双亲委派机制？"></a>3. 什么是双亲委派机制？为什么需要双亲委派机制？</h3><p>答：双亲委派机制是指：当一个类加载器收到类的加载请求的时候，会先看其父类加载器是否可以加载此类，依次这样递归，直到父类加载器可以加载这个类的时候，就返回，让这个父类加载器来加载这个类，如果没有父类可以加载的话，就自己加载。双亲委派机制可以防止一个类被重复加载，保证了类的唯一性。也可以保障java核心内库不被随意篡改。</p>
<h3 id="4-列举一些你知道的打破双亲委派机制的例子，为什么要打破？"><a href="#4-列举一些你知道的打破双亲委派机制的例子，为什么要打破？" class="headerlink" title="4. 列举一些你知道的打破双亲委派机制的例子，为什么要打破？"></a>4. 列举一些你知道的打破双亲委派机制的例子，为什么要打破？</h3><ul>
<li><p>JNDI 通过引入线程上下文类加载器，可以在 Thread.setContextClassLoader 方法设置，默认是应用程序类加载器，来加载 SPI 的代码。有了线程上下文类加载器，就可以完成父类加载器请求子类加载器完成类加载的行为。打破的原因，是为了 JNDI 服务的类加载器是启动器类加载，为了完成高级类加载器请求子类加载器（即上文中的线程上下文加载器）加载类。</p>
</li>
<li><p>Tomcat，应用的类加载器优先自行加载应用目录下的 class，并不是先委派给父加载器，加载不了才委派给父加载器。tomcat之所以造了一堆自己的classloader，大致是出于下面三类目的：tomcat类加载器如下图：</p>
</li>
<li><p>对于各个 webapp中的 class和 lib，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源。</p>
</li>
<li><p>与 jvm一样的安全性问题。使用单独的 classloader去装载 tomcat自身的类库，以免其他恶意或无意的破坏；</p>
</li>
<li><p>热部署。</p>
</li>
<li><p>OSGi，实现模块化热部署，为每个模块都自定义了类加载器，需要更换模块时，模块与类加载器一起更换。其类加载的过程中，有平级的类加载器加载行为。打破的原因是为了实现模块热替换。</p>
</li>
<li><p>JDK 9，Extension ClassLoader 被 Platform ClassLoader 取代，当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。打破的原因，是为了添加模块化的特性。</p>
</li>
</ul>
<h3 id="5-创建一个对象的步骤？"><a href="#5-创建一个对象的步骤？" class="headerlink" title="5. 创建一个对象的步骤？"></a>5. 创建一个对象的步骤？</h3><ol>
<li><p>判断这个对象是否经过了加载、验证、准备、解析、初始化的过程</p>
</li>
<li><p>为这个对象进行内存分配：</p>
</li>
<li><ul>
<li>如果内存是规整的，则进行指针碰撞</li>
<li>如果内存不是规整的，则进行空闲清单</li>
</ul>
</li>
<li><p>保证其并发安全：</p>
</li>
<li><ul>
<li>CAS保证更新的原子性</li>
</ul>
</li>
<li><ul>
<li>为每个线程都开辟TLAB</li>
</ul>
</li>
<li><p>初始化并赋默认值</p>
</li>
<li><p>设置对象头</p>
</li>
<li><p>执行init方法对变量进行赋值</p>
</li>
</ol>
<h3 id="6-对象头由什么构成？"><a href="#6-对象头由什么构成？" class="headerlink" title="6. 对象头由什么构成？"></a>6. 对象头由什么构成？</h3><p>运行时元数据：1. 哈希值 2.持有的锁 3.偏向的线程id 4.GC分代年龄 5.偏向的时间戳 6.锁状态标志</p>
<p>类型指针：指向了类元信息</p>
<h3 id="7-对象在JVM是如何存储的"><a href="#7-对象在JVM是如何存储的" class="headerlink" title="7. 对象在JVM是如何存储的?"></a>7. 对象在JVM是如何存储的?</h3><ol>
<li><p>对象头：</p>
</li>
<li><ol>
<li>运行时元数据：</li>
</ol>
</li>
<li><ol>
<li><ol>
<li>哈希值</li>
<li>GC分代年龄</li>
<li>持有的锁</li>
<li>锁状态标记</li>
<li>偏向的线程</li>
<li>偏向的时间戳</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li>类型指针：</li>
</ol>
</li>
<li><ol>
<li><ol>
<li>指向了方法区的类元信息</li>
</ol>
</li>
</ol>
</li>
<li><p>实例数据</p>
</li>
<li><p>对齐填充</p>
</li>
</ol>
<h3 id="8-说说JVM内存组成及其作用？"><a href="#8-说说JVM内存组成及其作用？" class="headerlink" title="8. 说说JVM内存组成及其作用？"></a>8. 说说JVM内存组成及其作用？</h3><ol>
<li><p>类加载器：类加载器只将类文件加载进内存。类加载器只管是否符合文件格式，是否运行，它不负责，由执行引擎负责</p>
</li>
<li><p>执行引擎：又叫做解释器，负责解释命令，然后交给操作系统</p>
</li>
<li><p>本地方法接口：本地方法接口融合了c&#x2F;c++语言为java使用</p>
</li>
<li><p>运行时数据区：</p>
</li>
<li><ol>
<li>程序计数器：程序计数器保存了下一个要执行的指令的地址</li>
<li>虚拟机栈：随着线程的创建而创建，与当前线程的周期一致，当方法被调用时，会压入一个又一个的栈帧里面保存了局部变量表、操作数栈、方法返回值、动态连接等，方法执行完毕会以先进后出的顺序进行弹出</li>
<li>本地方法栈：相对于虚拟机栈提供了java方法，本地方法栈提供了native修饰的方法，方法被调用时也会创建一个个栈帧</li>
<li>堆：一些new的对象和数组保存在里面</li>
<li>方法区：用于存储已经被类加载加载的类信息、域信息、静态变量、运行时常量池、被JIT即使编译器编译后的代码等信息</li>
</ol>
</li>
</ol>
<h3 id="9-说说栈和堆的区别？"><a href="#9-说说栈和堆的区别？" class="headerlink" title="9. 说说栈和堆的区别？"></a>9. 说说栈和堆的区别？</h3><ul>
<li>从功能上来讲：栈主要是存储一些方法，堆用来存储实例对象</li>
<li>从线程是否共享：栈是线程独有的，而堆是线程共享的</li>
<li>从大小来说：堆的内存远远大于栈</li>
</ul>
<h3 id="10-为什么有两个suvivor区？"><a href="#10-为什么有两个suvivor区？" class="headerlink" title="10. 为什么有两个suvivor区？"></a>10. 为什么有两个suvivor区？</h3><p>为了减少fullGC的次数</p>
<h3 id="11-eden和survivor区的比例是？"><a href="#11-eden和survivor区的比例是？" class="headerlink" title="11. eden和survivor区的比例是？"></a>11. eden和survivor区的比例是？</h3><p>8:1:1</p>
<h3 id="12-JVM内存中，为什么有新生代和老年代？"><a href="#12-JVM内存中，为什么有新生代和老年代？" class="headerlink" title="12. JVM内存中，为什么有新生代和老年代？"></a>12. JVM内存中，为什么有新生代和老年代？</h3><p>因为每个对象的生命周期不一样的，每个区需要执行垃圾回收的频率不一样，可以执行不同的垃圾回收算法来提高效率。</p>
<h3 id="13-new-String-“ab”-创建了多少个对象？"><a href="#13-new-String-“ab”-创建了多少个对象？" class="headerlink" title="13 new String(“ab”)创建了多少个对象？"></a>13 new String(“ab”)创建了多少个对象？</h3><ol>
<li>在堆中创建了实例       2. 在字符串常量池中的对象</li>
</ol>
<h3 id="14-new-String-“a”-new-String-“b”-创建了多少个对象？"><a href="#14-new-String-“a”-new-String-“b”-创建了多少个对象？" class="headerlink" title="14 new String(“a”) + new String(“b”)创建了多少个对象？"></a>14 new String(“a”) + new String(“b”)创建了多少个对象？</h3><ol>
<li>new StringBuilder  2. new String(“a”)   3.new String(“b”)  4.常量池a  5.常量池b  6.toString()创建出了new String(“ab”)    注意没有常量池的ab</li>
</ol>
<h3 id="15-怎么判断对象是否被回收？"><a href="#15-怎么判断对象是否被回收？" class="headerlink" title="15 怎么判断对象是否被回收？"></a>15 怎么判断对象是否被回收？</h3><ol>
<li>引用计数算法：为每个对象创建引用计数，一旦对象被引用就+1，引用被释放就-1，引用指数为0的就是要被回收的对象。</li>
<li>可达性算法：从GC ROOTS往下搜索，走过的路径就是引用链，没被引用链连接的就是可以回收的对象</li>
</ol>
<p> jvm的GC ROOTS有哪几个地方呢？</p>
<p>  1、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&spm=1001.2101.3001.7020">虚拟机</a>栈（局部变量表中引用的对象）</p>
<p>  2、本地方法栈（本地方法引用的对象）</p>
<p>  3、方法区中静态属性引用的对象</p>
<p>  4、方法区中静态常量池中引用的对象</p>
<h3 id="16-说下GC算法各有什么优劣，分代回收说下"><a href="#16-说下GC算法各有什么优劣，分代回收说下" class="headerlink" title="16 说下GC算法各有什么优劣，分代回收说下"></a>16 说下GC算法各有什么优劣，分代回收说下</h3><blockquote>
<p>标记清除：</p>
</blockquote>
<p>从GC Root开始遍历，标记所有被引用的对象，清除掉没被标记的对象。缺点：存在内存碎片</p>
<p>优点：简单，效率还行</p>
<blockquote>
<p>标记压缩</p>
</blockquote>
<p>从GC Root开始遍历，标记所有被引用的对象，并将这些对象移动到边界，再清除掉边界外的对象。 缺点：要移动对象，效率低下  优点：内存规整不存在碎片  </p>
<blockquote>
<p>复制算法</p>
</blockquote>
<p>将内存划分为两个部分，将一块内存用完时，将活的对象复制到另一块上，再将使用过的清除掉</p>
<p>缺点：每次都只使用到了一半内存对内存的压力很大  优点：内存规整不存在碎片，效率高</p>
<blockquote>
<p>分代回收</p>
</blockquote>
<p>根据对象生命周期的不同将内存分为新生代和老年代，新生代因为存活对象少，所以用复制算法。老年代用标记压缩算法</p>
<h3 id="17-System-gc-和Runtime-gc-会做什么事情？"><a href="#17-System-gc-和Runtime-gc-会做什么事情？" class="headerlink" title="17 System.gc()和Runtime.gc()会做什么事情？"></a>17 System.gc()和Runtime.gc()会做什么事情？</h3><p>都会提醒JVM进行垃圾回收，但是否立即或延缓执行是取决于JVM的。</p>
<h3 id="18-说说有哪些垃圾回收器，重点说下CMS和G1"><a href="#18-说说有哪些垃圾回收器，重点说下CMS和G1" class="headerlink" title="18 说说有哪些垃圾回收器，重点说下CMS和G1"></a>18 说说有哪些垃圾回收器，重点说下CMS和G1</h3><ol>
<li>Serial 回收器：新生代单线程的回收器，回收算法是复制算法</li>
<li>Serial Old 回收器：老年代单线程回收器，回收算法是标记整理算法</li>
<li>ParNew 回收器：是Serial的多线程版本，处理新生代的垃圾回收，回收算法是复制算法</li>
<li>Parallel回收器：也是多线程的，以吞吐量优先的回收器，牺牲等待时间获取最大的吞吐量，新生代回收算法是复制算法</li>
<li>ParallelOld回收器：是Parallel 的老年代版本的，回收算法是标记整理</li>
<li>CMS回收器：是第一款真正意义上的并发处理器，以牺牲吞吐量获取低等待时间为目标。对于要求服务响应速度严格的应用很适合。CMS的回收算法是标记清除算法，会产生很多内存碎片。CMS的主要过程是初始标记、并发标记、重新标记、并发清除。</li>
<li>G1回收器：是一种兼顾吞吐量和停顿时间的回收器，回收算法是标记整理算法，不会产生内存碎片，可以精确控制停顿。主要过程有初始标记、并发标记、最终标记、筛选标记</li>
</ol>
<h3 id="19-常用的JVM调优参数"><a href="#19-常用的JVM调优参数" class="headerlink" title="19 常用的JVM调优参数"></a>19 常用的JVM调优参数</h3><ul>
<li>-Xms2g:初始堆大小2g</li>
<li>-Xmx2g:最大堆大小2g</li>
<li>Xmn:新生代内存</li>
<li>Xss：栈大小</li>
<li>-XX:NewRatio&#x3D;4:新生代和老年代的内存比例是1:4</li>
<li>-XX:MaxPermSize&#x3D;n:设置永久代大小</li>
<li>-XX:SuvivorRatio&#x3D;8:Eden园区与Suvivor区比例是8:2</li>
<li>-XX:+Use…GC</li>
<li>-XX:+PrintGCDetail：打印gc过程信息</li>
</ul>
<h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><h3 id="1-生产者生产消息是如何放到队列中的？"><a href="#1-生产者生产消息是如何放到队列中的？" class="headerlink" title="1. 生产者生产消息是如何放到队列中的？"></a>1. 生产者生产消息是如何放到队列中的？</h3><p>Rbmq:生产者投递消息到exchange 上，exchange会把消息路由到指定的queue上，（根据某种路由规则去路由的）消费者只需要监听mq然后去消费就可以了</p>
<h3 id="2-RabbitMq优缺点？"><a href="#2-RabbitMq优缺点？" class="headerlink" title="2. RabbitMq优缺点？"></a>2. RabbitMq优缺点？</h3><p>答：优点：</p>
<p>1.<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%A7%A3%E8%80%A6&spm=1001.2101.3001.7020">解耦</a>，系统A在代码中直接调用系统B和系统C的代码，如果将来D系统接入，系统A还需要修改代码，过于麻烦！<br>2.异步，将消息写入<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97&spm=1001.2101.3001.7020">消息队列</a>，非必要的业务逻辑以异步的方式运行，加快响应速度<br>3.削峰，并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常</p>
<p>缺点：</p>
<ol>
<li>依赖于broker的可靠性和安全性，稳定性</li>
<li>会增加系统的复杂程度，没有明显的流程线，不好追踪。</li>
</ol>
<h3 id="3-RabbitMq的工作模式？"><a href="#3-RabbitMq的工作模式？" class="headerlink" title="3. RabbitMq的工作模式？"></a>3. RabbitMq的工作模式？</h3><ol>
<li><strong>基本消息模型</strong></li>
</ol>
<p>一个生产者对应一个消费者，生产者生产一个消息到队列，消费者消费这个消息。</p>
<ol>
<li><strong>工作队列模式：</strong></li>
</ol>
<p>在实际生产过程中，消息生产会发送很多条消息，如果消费者只有一个的花效率就会很低</p>
<p>一个生产者发送消息到队列，允许有多个消费者接收消息，但是一条消息只会被一个消费者获取。</p>
<ol>
<li><strong>订阅模式</strong></li>
</ol>
<p>在订阅模式中，一条消息可以被多个消费者获取。</p>
<p>消息传递过程中多了一个交换机，生产者不是直接发送消息到队列，而是先发送到交换机，经由交换机分配到不同的队列，每个消费者都有自己的队列。</p>
<ol>
<li><strong>fanout 广播模式</strong></li>
</ol>
<p>每个消费者都有自己的队列，队列和交换机绑定，交换机把消息发送到队列中</p>
<ol>
<li><strong>direct 路由模式</strong></li>
</ol>
<p>在路由模式下可以实现不同的消息被不同的队列消费。</p>
<p>交换机和队列绑定的时候会设定一个routing key ，生产者发送消息的时候也需要携带一个routing key</p>
<ol>
<li><strong>topic 路由匹配模式</strong></li>
</ol>
<p>跟路由模式一样，只不过路由名称可以进</p>
<h3 id="4-Kafka的有什么特点？"><a href="#4-Kafka的有什么特点？" class="headerlink" title="4. Kafka的有什么特点？"></a>4. Kafka的有什么特点？</h3><ol>
<li><strong>高吞吐量、低延迟：</strong>kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。</li>
<li><strong>持久性、可靠性：</strong>消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li>
<li><strong>容错性：</strong>允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li>
<li><strong>高并发：</strong>支持数千个客户端同时读写</li>
</ol>
<h3 id="5-消息中间件是什么"><a href="#5-消息中间件是什么" class="headerlink" title="5. 消息中间件是什么"></a>5. 消息中间件是什么</h3><blockquote>
<p>是利用高效可靠的消息传递机制进行异步的数据传输，并基于数据通信进行分布式系统的集成。通过提供消息队列模型和消息传递机制，可以在分布式环境下扩展进程间的通信</p>
</blockquote>
<h3 id="6-消息中间件的两种传递模式"><a href="#6-消息中间件的两种传递模式" class="headerlink" title="6. 消息中间件的两种传递模式"></a>6. 消息中间件的两种传递模式</h3><ul>
<li>点对点模式</li>
<li>发布&#x2F;订阅模式</li>
</ul>
<h3 id="7-Kafka生产者发送消息确认机制-ack机制"><a href="#7-Kafka生产者发送消息确认机制-ack机制" class="headerlink" title="7. Kafka生产者发送消息确认机制(ack机制)"></a>7. Kafka生产者发送消息确认机制(ack机制)</h3><p>acks 生产者投递消息的ACK的级别设置<br>如果需要等到ISR所有的follower副本返回消息leader，可能需要等待，便产生了不同的ack可靠性级别</p>
<ol>
<li>acks&#x3D;0 消费者只管投递消息，leader一接收到消息还没有写入磁盘就返回ack<br>优点：延迟性最低<br>缺点：如果接收到消息后leader没有写入磁盘就挂掉，从ISR中的follower新选举leader后，会丢失数据</li>
<li>acks&#x3D;1(默认)： 至少要等待leader已经成功将数据写入本地log，但是不需要等待所有follower是否成功写入。就可以继续发送下一条消息。这种情况下，如果follower没有成功备份数据，而此时leader又挂掉，则消息会丢失。</li>
<li>acks&#x3D;-1或all： 需要等待 min.insync.replicas(默认为 1 ，推荐配置大于等于2) 这个参数配置的副本个数都成功写入日志，这种策略会保证只要有一个备份存活就不会丢失数据。这是最强的数据保证。一般除非是金融级别，或跟钱打交道的场景才会使用这种配置。</li>
</ol>
<h3 id="8-如何防止消息丢失？"><a href="#8-如何防止消息丢失？" class="headerlink" title="8. 如何防止消息丢失？"></a>8. 如何防止消息丢失？</h3><ul>
<li>发送方： ack是 1 或者-1&#x2F;all 可以防止消息丢失，如果要做到99.9999%，ack设成all，把min.insync.replicas配置成分区备份数</li>
<li>消费方：把自动提交改为手动提交</li>
</ul>
<h3 id="9-如何防止消息重复消费？"><a href="#9-如何防止消息重复消费？" class="headerlink" title="9. 如何防止消息重复消费？"></a>9. 如何防止消息重复消费？</h3><ul>
<li>mysql 插入业务id作为主键，主键是唯一的，所以一次只能插入一条</li>
<li>使用redis或zk的分布式锁（主流的方案）</li>
</ul>
<h3 id="10-如何做到顺序消费？"><a href="#10-如何做到顺序消费？" class="headerlink" title="10. 如何做到顺序消费？"></a>10. 如何做到顺序消费？</h3><ul>
<li>发送方：在发送时将ack不能设置 0 ，关闭重试，使用同步发送，等到发送成功再发送下一条。确保消息是顺序发送的。</li>
<li>接收方：消息是发送到一个分区中，只能有一个消费组的消费者来接收消息。因此，kafka的顺序消费会牺牲掉性能。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95/" class="category-chain-item">面试</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="print-no-link">#面试总结</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试常见题</div>
      <div>http://example.com/2022/05/01/面试题归纳/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>gaozhe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年5月1日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/06/16/MySQL45%E8%AE%B2/" title="MySql45讲">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">MySql45讲</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/26/SpringSecurity/" title="SpringSecurity">
                        <span class="hidden-mobile">SpringSecurity</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
